package executor

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/insolar/jet"
)

// JetKeeperMock implements JetKeeper
type JetKeeperMock struct {
	t minimock.Tester

	funcAddBackupConfirmation          func(ctx context.Context, pn insolar.PulseNumber) (err error)
	inspectFuncAddBackupConfirmation   func(ctx context.Context, pn insolar.PulseNumber)
	afterAddBackupConfirmationCounter  uint64
	beforeAddBackupConfirmationCounter uint64
	AddBackupConfirmationMock          mJetKeeperMockAddBackupConfirmation

	funcAddDropConfirmation          func(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) (err error)
	inspectFuncAddDropConfirmation   func(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool)
	afterAddDropConfirmationCounter  uint64
	beforeAddDropConfirmationCounter uint64
	AddDropConfirmationMock          mJetKeeperMockAddDropConfirmation

	funcAddHotConfirmation          func(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) (err error)
	inspectFuncAddHotConfirmation   func(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool)
	afterAddHotConfirmationCounter  uint64
	beforeAddHotConfirmationCounter uint64
	AddHotConfirmationMock          mJetKeeperMockAddHotConfirmation

	funcHasAllJetConfirms          func(ctx context.Context, pn insolar.PulseNumber) (b1 bool)
	inspectFuncHasAllJetConfirms   func(ctx context.Context, pn insolar.PulseNumber)
	afterHasAllJetConfirmsCounter  uint64
	beforeHasAllJetConfirmsCounter uint64
	HasAllJetConfirmsMock          mJetKeeperMockHasAllJetConfirms

	funcStorage          func() (s1 jet.Storage)
	inspectFuncStorage   func()
	afterStorageCounter  uint64
	beforeStorageCounter uint64
	StorageMock          mJetKeeperMockStorage

	funcTopSyncPulse          func() (p1 insolar.PulseNumber)
	inspectFuncTopSyncPulse   func()
	afterTopSyncPulseCounter  uint64
	beforeTopSyncPulseCounter uint64
	TopSyncPulseMock          mJetKeeperMockTopSyncPulse
}

// NewJetKeeperMock returns a mock for JetKeeper
func NewJetKeeperMock(t minimock.Tester) *JetKeeperMock {
	m := &JetKeeperMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddBackupConfirmationMock = mJetKeeperMockAddBackupConfirmation{mock: m}
	m.AddBackupConfirmationMock.callArgs = []*JetKeeperMockAddBackupConfirmationParams{}

	m.AddDropConfirmationMock = mJetKeeperMockAddDropConfirmation{mock: m}
	m.AddDropConfirmationMock.callArgs = []*JetKeeperMockAddDropConfirmationParams{}

	m.AddHotConfirmationMock = mJetKeeperMockAddHotConfirmation{mock: m}
	m.AddHotConfirmationMock.callArgs = []*JetKeeperMockAddHotConfirmationParams{}

	m.HasAllJetConfirmsMock = mJetKeeperMockHasAllJetConfirms{mock: m}
	m.HasAllJetConfirmsMock.callArgs = []*JetKeeperMockHasAllJetConfirmsParams{}

	m.StorageMock = mJetKeeperMockStorage{mock: m}

	m.TopSyncPulseMock = mJetKeeperMockTopSyncPulse{mock: m}

	return m
}

type mJetKeeperMockAddBackupConfirmation struct {
	mock               *JetKeeperMock
	defaultExpectation *JetKeeperMockAddBackupConfirmationExpectation
	expectations       []*JetKeeperMockAddBackupConfirmationExpectation

	callArgs []*JetKeeperMockAddBackupConfirmationParams
	mutex    sync.RWMutex
}

// JetKeeperMockAddBackupConfirmationExpectation specifies expectation struct of the JetKeeper.AddBackupConfirmation
type JetKeeperMockAddBackupConfirmationExpectation struct {
	mock    *JetKeeperMock
	params  *JetKeeperMockAddBackupConfirmationParams
	results *JetKeeperMockAddBackupConfirmationResults
	Counter uint64
}

// JetKeeperMockAddBackupConfirmationParams contains parameters of the JetKeeper.AddBackupConfirmation
type JetKeeperMockAddBackupConfirmationParams struct {
	ctx context.Context
	pn  insolar.PulseNumber
}

// JetKeeperMockAddBackupConfirmationResults contains results of the JetKeeper.AddBackupConfirmation
type JetKeeperMockAddBackupConfirmationResults struct {
	err error
}

// Expect sets up expected params for JetKeeper.AddBackupConfirmation
func (mmAddBackupConfirmation *mJetKeeperMockAddBackupConfirmation) Expect(ctx context.Context, pn insolar.PulseNumber) *mJetKeeperMockAddBackupConfirmation {
	if mmAddBackupConfirmation.mock.funcAddBackupConfirmation != nil {
		mmAddBackupConfirmation.mock.t.Fatalf("JetKeeperMock.AddBackupConfirmation mock is already set by Set")
	}

	if mmAddBackupConfirmation.defaultExpectation == nil {
		mmAddBackupConfirmation.defaultExpectation = &JetKeeperMockAddBackupConfirmationExpectation{}
	}

	mmAddBackupConfirmation.defaultExpectation.params = &JetKeeperMockAddBackupConfirmationParams{ctx, pn}
	for _, e := range mmAddBackupConfirmation.expectations {
		if minimock.Equal(e.params, mmAddBackupConfirmation.defaultExpectation.params) {
			mmAddBackupConfirmation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddBackupConfirmation.defaultExpectation.params)
		}
	}

	return mmAddBackupConfirmation
}

// Inspect accepts an inspector function that has same arguments as the JetKeeper.AddBackupConfirmation
func (mmAddBackupConfirmation *mJetKeeperMockAddBackupConfirmation) Inspect(f func(ctx context.Context, pn insolar.PulseNumber)) *mJetKeeperMockAddBackupConfirmation {
	if mmAddBackupConfirmation.mock.inspectFuncAddBackupConfirmation != nil {
		mmAddBackupConfirmation.mock.t.Fatalf("Inspect function is already set for JetKeeperMock.AddBackupConfirmation")
	}

	mmAddBackupConfirmation.mock.inspectFuncAddBackupConfirmation = f

	return mmAddBackupConfirmation
}

// Return sets up results that will be returned by JetKeeper.AddBackupConfirmation
func (mmAddBackupConfirmation *mJetKeeperMockAddBackupConfirmation) Return(err error) *JetKeeperMock {
	if mmAddBackupConfirmation.mock.funcAddBackupConfirmation != nil {
		mmAddBackupConfirmation.mock.t.Fatalf("JetKeeperMock.AddBackupConfirmation mock is already set by Set")
	}

	if mmAddBackupConfirmation.defaultExpectation == nil {
		mmAddBackupConfirmation.defaultExpectation = &JetKeeperMockAddBackupConfirmationExpectation{mock: mmAddBackupConfirmation.mock}
	}
	mmAddBackupConfirmation.defaultExpectation.results = &JetKeeperMockAddBackupConfirmationResults{err}
	return mmAddBackupConfirmation.mock
}

//Set uses given function f to mock the JetKeeper.AddBackupConfirmation method
func (mmAddBackupConfirmation *mJetKeeperMockAddBackupConfirmation) Set(f func(ctx context.Context, pn insolar.PulseNumber) (err error)) *JetKeeperMock {
	if mmAddBackupConfirmation.defaultExpectation != nil {
		mmAddBackupConfirmation.mock.t.Fatalf("Default expectation is already set for the JetKeeper.AddBackupConfirmation method")
	}

	if len(mmAddBackupConfirmation.expectations) > 0 {
		mmAddBackupConfirmation.mock.t.Fatalf("Some expectations are already set for the JetKeeper.AddBackupConfirmation method")
	}

	mmAddBackupConfirmation.mock.funcAddBackupConfirmation = f
	return mmAddBackupConfirmation.mock
}

// When sets expectation for the JetKeeper.AddBackupConfirmation which will trigger the result defined by the following
// Then helper
func (mmAddBackupConfirmation *mJetKeeperMockAddBackupConfirmation) When(ctx context.Context, pn insolar.PulseNumber) *JetKeeperMockAddBackupConfirmationExpectation {
	if mmAddBackupConfirmation.mock.funcAddBackupConfirmation != nil {
		mmAddBackupConfirmation.mock.t.Fatalf("JetKeeperMock.AddBackupConfirmation mock is already set by Set")
	}

	expectation := &JetKeeperMockAddBackupConfirmationExpectation{
		mock:   mmAddBackupConfirmation.mock,
		params: &JetKeeperMockAddBackupConfirmationParams{ctx, pn},
	}
	mmAddBackupConfirmation.expectations = append(mmAddBackupConfirmation.expectations, expectation)
	return expectation
}

// Then sets up JetKeeper.AddBackupConfirmation return parameters for the expectation previously defined by the When method
func (e *JetKeeperMockAddBackupConfirmationExpectation) Then(err error) *JetKeeperMock {
	e.results = &JetKeeperMockAddBackupConfirmationResults{err}
	return e.mock
}

// AddBackupConfirmation implements JetKeeper
func (mmAddBackupConfirmation *JetKeeperMock) AddBackupConfirmation(ctx context.Context, pn insolar.PulseNumber) (err error) {
	mm_atomic.AddUint64(&mmAddBackupConfirmation.beforeAddBackupConfirmationCounter, 1)
	defer mm_atomic.AddUint64(&mmAddBackupConfirmation.afterAddBackupConfirmationCounter, 1)

	if mmAddBackupConfirmation.inspectFuncAddBackupConfirmation != nil {
		mmAddBackupConfirmation.inspectFuncAddBackupConfirmation(ctx, pn)
	}

	mm_params := &JetKeeperMockAddBackupConfirmationParams{ctx, pn}

	// Record call args
	mmAddBackupConfirmation.AddBackupConfirmationMock.mutex.Lock()
	mmAddBackupConfirmation.AddBackupConfirmationMock.callArgs = append(mmAddBackupConfirmation.AddBackupConfirmationMock.callArgs, mm_params)
	mmAddBackupConfirmation.AddBackupConfirmationMock.mutex.Unlock()

	for _, e := range mmAddBackupConfirmation.AddBackupConfirmationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddBackupConfirmation.AddBackupConfirmationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddBackupConfirmation.AddBackupConfirmationMock.defaultExpectation.Counter, 1)
		mm_want := mmAddBackupConfirmation.AddBackupConfirmationMock.defaultExpectation.params
		mm_got := JetKeeperMockAddBackupConfirmationParams{ctx, pn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddBackupConfirmation.t.Errorf("JetKeeperMock.AddBackupConfirmation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddBackupConfirmation.AddBackupConfirmationMock.defaultExpectation.results
		if mm_results == nil {
			mmAddBackupConfirmation.t.Fatal("No results are set for the JetKeeperMock.AddBackupConfirmation")
		}
		return (*mm_results).err
	}
	if mmAddBackupConfirmation.funcAddBackupConfirmation != nil {
		return mmAddBackupConfirmation.funcAddBackupConfirmation(ctx, pn)
	}
	mmAddBackupConfirmation.t.Fatalf("Unexpected call to JetKeeperMock.AddBackupConfirmation. %v %v", ctx, pn)
	return
}

// AddBackupConfirmationAfterCounter returns a count of finished JetKeeperMock.AddBackupConfirmation invocations
func (mmAddBackupConfirmation *JetKeeperMock) AddBackupConfirmationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddBackupConfirmation.afterAddBackupConfirmationCounter)
}

// AddBackupConfirmationBeforeCounter returns a count of JetKeeperMock.AddBackupConfirmation invocations
func (mmAddBackupConfirmation *JetKeeperMock) AddBackupConfirmationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddBackupConfirmation.beforeAddBackupConfirmationCounter)
}

// Calls returns a list of arguments used in each call to JetKeeperMock.AddBackupConfirmation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddBackupConfirmation *mJetKeeperMockAddBackupConfirmation) Calls() []*JetKeeperMockAddBackupConfirmationParams {
	mmAddBackupConfirmation.mutex.RLock()

	argCopy := make([]*JetKeeperMockAddBackupConfirmationParams, len(mmAddBackupConfirmation.callArgs))
	copy(argCopy, mmAddBackupConfirmation.callArgs)

	mmAddBackupConfirmation.mutex.RUnlock()

	return argCopy
}

// MinimockAddBackupConfirmationDone returns true if the count of the AddBackupConfirmation invocations corresponds
// the number of defined expectations
func (m *JetKeeperMock) MinimockAddBackupConfirmationDone() bool {
	for _, e := range m.AddBackupConfirmationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddBackupConfirmationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddBackupConfirmationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddBackupConfirmation != nil && mm_atomic.LoadUint64(&m.afterAddBackupConfirmationCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddBackupConfirmationInspect logs each unmet expectation
func (m *JetKeeperMock) MinimockAddBackupConfirmationInspect() {
	for _, e := range m.AddBackupConfirmationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JetKeeperMock.AddBackupConfirmation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddBackupConfirmationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddBackupConfirmationCounter) < 1 {
		if m.AddBackupConfirmationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to JetKeeperMock.AddBackupConfirmation")
		} else {
			m.t.Errorf("Expected call to JetKeeperMock.AddBackupConfirmation with params: %#v", *m.AddBackupConfirmationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddBackupConfirmation != nil && mm_atomic.LoadUint64(&m.afterAddBackupConfirmationCounter) < 1 {
		m.t.Error("Expected call to JetKeeperMock.AddBackupConfirmation")
	}
}

type mJetKeeperMockAddDropConfirmation struct {
	mock               *JetKeeperMock
	defaultExpectation *JetKeeperMockAddDropConfirmationExpectation
	expectations       []*JetKeeperMockAddDropConfirmationExpectation

	callArgs []*JetKeeperMockAddDropConfirmationParams
	mutex    sync.RWMutex
}

// JetKeeperMockAddDropConfirmationExpectation specifies expectation struct of the JetKeeper.AddDropConfirmation
type JetKeeperMockAddDropConfirmationExpectation struct {
	mock    *JetKeeperMock
	params  *JetKeeperMockAddDropConfirmationParams
	results *JetKeeperMockAddDropConfirmationResults
	Counter uint64
}

// JetKeeperMockAddDropConfirmationParams contains parameters of the JetKeeper.AddDropConfirmation
type JetKeeperMockAddDropConfirmationParams struct {
	ctx   context.Context
	pn    insolar.PulseNumber
	jet   insolar.JetID
	split bool
}

// JetKeeperMockAddDropConfirmationResults contains results of the JetKeeper.AddDropConfirmation
type JetKeeperMockAddDropConfirmationResults struct {
	err error
}

// Expect sets up expected params for JetKeeper.AddDropConfirmation
func (mmAddDropConfirmation *mJetKeeperMockAddDropConfirmation) Expect(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) *mJetKeeperMockAddDropConfirmation {
	if mmAddDropConfirmation.mock.funcAddDropConfirmation != nil {
		mmAddDropConfirmation.mock.t.Fatalf("JetKeeperMock.AddDropConfirmation mock is already set by Set")
	}

	if mmAddDropConfirmation.defaultExpectation == nil {
		mmAddDropConfirmation.defaultExpectation = &JetKeeperMockAddDropConfirmationExpectation{}
	}

	mmAddDropConfirmation.defaultExpectation.params = &JetKeeperMockAddDropConfirmationParams{ctx, pn, jet, split}
	for _, e := range mmAddDropConfirmation.expectations {
		if minimock.Equal(e.params, mmAddDropConfirmation.defaultExpectation.params) {
			mmAddDropConfirmation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddDropConfirmation.defaultExpectation.params)
		}
	}

	return mmAddDropConfirmation
}

// Inspect accepts an inspector function that has same arguments as the JetKeeper.AddDropConfirmation
func (mmAddDropConfirmation *mJetKeeperMockAddDropConfirmation) Inspect(f func(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool)) *mJetKeeperMockAddDropConfirmation {
	if mmAddDropConfirmation.mock.inspectFuncAddDropConfirmation != nil {
		mmAddDropConfirmation.mock.t.Fatalf("Inspect function is already set for JetKeeperMock.AddDropConfirmation")
	}

	mmAddDropConfirmation.mock.inspectFuncAddDropConfirmation = f

	return mmAddDropConfirmation
}

// Return sets up results that will be returned by JetKeeper.AddDropConfirmation
func (mmAddDropConfirmation *mJetKeeperMockAddDropConfirmation) Return(err error) *JetKeeperMock {
	if mmAddDropConfirmation.mock.funcAddDropConfirmation != nil {
		mmAddDropConfirmation.mock.t.Fatalf("JetKeeperMock.AddDropConfirmation mock is already set by Set")
	}

	if mmAddDropConfirmation.defaultExpectation == nil {
		mmAddDropConfirmation.defaultExpectation = &JetKeeperMockAddDropConfirmationExpectation{mock: mmAddDropConfirmation.mock}
	}
	mmAddDropConfirmation.defaultExpectation.results = &JetKeeperMockAddDropConfirmationResults{err}
	return mmAddDropConfirmation.mock
}

//Set uses given function f to mock the JetKeeper.AddDropConfirmation method
func (mmAddDropConfirmation *mJetKeeperMockAddDropConfirmation) Set(f func(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) (err error)) *JetKeeperMock {
	if mmAddDropConfirmation.defaultExpectation != nil {
		mmAddDropConfirmation.mock.t.Fatalf("Default expectation is already set for the JetKeeper.AddDropConfirmation method")
	}

	if len(mmAddDropConfirmation.expectations) > 0 {
		mmAddDropConfirmation.mock.t.Fatalf("Some expectations are already set for the JetKeeper.AddDropConfirmation method")
	}

	mmAddDropConfirmation.mock.funcAddDropConfirmation = f
	return mmAddDropConfirmation.mock
}

// When sets expectation for the JetKeeper.AddDropConfirmation which will trigger the result defined by the following
// Then helper
func (mmAddDropConfirmation *mJetKeeperMockAddDropConfirmation) When(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) *JetKeeperMockAddDropConfirmationExpectation {
	if mmAddDropConfirmation.mock.funcAddDropConfirmation != nil {
		mmAddDropConfirmation.mock.t.Fatalf("JetKeeperMock.AddDropConfirmation mock is already set by Set")
	}

	expectation := &JetKeeperMockAddDropConfirmationExpectation{
		mock:   mmAddDropConfirmation.mock,
		params: &JetKeeperMockAddDropConfirmationParams{ctx, pn, jet, split},
	}
	mmAddDropConfirmation.expectations = append(mmAddDropConfirmation.expectations, expectation)
	return expectation
}

// Then sets up JetKeeper.AddDropConfirmation return parameters for the expectation previously defined by the When method
func (e *JetKeeperMockAddDropConfirmationExpectation) Then(err error) *JetKeeperMock {
	e.results = &JetKeeperMockAddDropConfirmationResults{err}
	return e.mock
}

// AddDropConfirmation implements JetKeeper
func (mmAddDropConfirmation *JetKeeperMock) AddDropConfirmation(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) (err error) {
	mm_atomic.AddUint64(&mmAddDropConfirmation.beforeAddDropConfirmationCounter, 1)
	defer mm_atomic.AddUint64(&mmAddDropConfirmation.afterAddDropConfirmationCounter, 1)

	if mmAddDropConfirmation.inspectFuncAddDropConfirmation != nil {
		mmAddDropConfirmation.inspectFuncAddDropConfirmation(ctx, pn, jet, split)
	}

	mm_params := &JetKeeperMockAddDropConfirmationParams{ctx, pn, jet, split}

	// Record call args
	mmAddDropConfirmation.AddDropConfirmationMock.mutex.Lock()
	mmAddDropConfirmation.AddDropConfirmationMock.callArgs = append(mmAddDropConfirmation.AddDropConfirmationMock.callArgs, mm_params)
	mmAddDropConfirmation.AddDropConfirmationMock.mutex.Unlock()

	for _, e := range mmAddDropConfirmation.AddDropConfirmationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddDropConfirmation.AddDropConfirmationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddDropConfirmation.AddDropConfirmationMock.defaultExpectation.Counter, 1)
		mm_want := mmAddDropConfirmation.AddDropConfirmationMock.defaultExpectation.params
		mm_got := JetKeeperMockAddDropConfirmationParams{ctx, pn, jet, split}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddDropConfirmation.t.Errorf("JetKeeperMock.AddDropConfirmation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddDropConfirmation.AddDropConfirmationMock.defaultExpectation.results
		if mm_results == nil {
			mmAddDropConfirmation.t.Fatal("No results are set for the JetKeeperMock.AddDropConfirmation")
		}
		return (*mm_results).err
	}
	if mmAddDropConfirmation.funcAddDropConfirmation != nil {
		return mmAddDropConfirmation.funcAddDropConfirmation(ctx, pn, jet, split)
	}
	mmAddDropConfirmation.t.Fatalf("Unexpected call to JetKeeperMock.AddDropConfirmation. %v %v %v %v", ctx, pn, jet, split)
	return
}

// AddDropConfirmationAfterCounter returns a count of finished JetKeeperMock.AddDropConfirmation invocations
func (mmAddDropConfirmation *JetKeeperMock) AddDropConfirmationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddDropConfirmation.afterAddDropConfirmationCounter)
}

// AddDropConfirmationBeforeCounter returns a count of JetKeeperMock.AddDropConfirmation invocations
func (mmAddDropConfirmation *JetKeeperMock) AddDropConfirmationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddDropConfirmation.beforeAddDropConfirmationCounter)
}

// Calls returns a list of arguments used in each call to JetKeeperMock.AddDropConfirmation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddDropConfirmation *mJetKeeperMockAddDropConfirmation) Calls() []*JetKeeperMockAddDropConfirmationParams {
	mmAddDropConfirmation.mutex.RLock()

	argCopy := make([]*JetKeeperMockAddDropConfirmationParams, len(mmAddDropConfirmation.callArgs))
	copy(argCopy, mmAddDropConfirmation.callArgs)

	mmAddDropConfirmation.mutex.RUnlock()

	return argCopy
}

// MinimockAddDropConfirmationDone returns true if the count of the AddDropConfirmation invocations corresponds
// the number of defined expectations
func (m *JetKeeperMock) MinimockAddDropConfirmationDone() bool {
	for _, e := range m.AddDropConfirmationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddDropConfirmationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddDropConfirmationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddDropConfirmation != nil && mm_atomic.LoadUint64(&m.afterAddDropConfirmationCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddDropConfirmationInspect logs each unmet expectation
func (m *JetKeeperMock) MinimockAddDropConfirmationInspect() {
	for _, e := range m.AddDropConfirmationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JetKeeperMock.AddDropConfirmation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddDropConfirmationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddDropConfirmationCounter) < 1 {
		if m.AddDropConfirmationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to JetKeeperMock.AddDropConfirmation")
		} else {
			m.t.Errorf("Expected call to JetKeeperMock.AddDropConfirmation with params: %#v", *m.AddDropConfirmationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddDropConfirmation != nil && mm_atomic.LoadUint64(&m.afterAddDropConfirmationCounter) < 1 {
		m.t.Error("Expected call to JetKeeperMock.AddDropConfirmation")
	}
}

type mJetKeeperMockAddHotConfirmation struct {
	mock               *JetKeeperMock
	defaultExpectation *JetKeeperMockAddHotConfirmationExpectation
	expectations       []*JetKeeperMockAddHotConfirmationExpectation

	callArgs []*JetKeeperMockAddHotConfirmationParams
	mutex    sync.RWMutex
}

// JetKeeperMockAddHotConfirmationExpectation specifies expectation struct of the JetKeeper.AddHotConfirmation
type JetKeeperMockAddHotConfirmationExpectation struct {
	mock    *JetKeeperMock
	params  *JetKeeperMockAddHotConfirmationParams
	results *JetKeeperMockAddHotConfirmationResults
	Counter uint64
}

// JetKeeperMockAddHotConfirmationParams contains parameters of the JetKeeper.AddHotConfirmation
type JetKeeperMockAddHotConfirmationParams struct {
	ctx   context.Context
	pn    insolar.PulseNumber
	jet   insolar.JetID
	split bool
}

// JetKeeperMockAddHotConfirmationResults contains results of the JetKeeper.AddHotConfirmation
type JetKeeperMockAddHotConfirmationResults struct {
	err error
}

// Expect sets up expected params for JetKeeper.AddHotConfirmation
func (mmAddHotConfirmation *mJetKeeperMockAddHotConfirmation) Expect(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) *mJetKeeperMockAddHotConfirmation {
	if mmAddHotConfirmation.mock.funcAddHotConfirmation != nil {
		mmAddHotConfirmation.mock.t.Fatalf("JetKeeperMock.AddHotConfirmation mock is already set by Set")
	}

	if mmAddHotConfirmation.defaultExpectation == nil {
		mmAddHotConfirmation.defaultExpectation = &JetKeeperMockAddHotConfirmationExpectation{}
	}

	mmAddHotConfirmation.defaultExpectation.params = &JetKeeperMockAddHotConfirmationParams{ctx, pn, jet, split}
	for _, e := range mmAddHotConfirmation.expectations {
		if minimock.Equal(e.params, mmAddHotConfirmation.defaultExpectation.params) {
			mmAddHotConfirmation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddHotConfirmation.defaultExpectation.params)
		}
	}

	return mmAddHotConfirmation
}

// Inspect accepts an inspector function that has same arguments as the JetKeeper.AddHotConfirmation
func (mmAddHotConfirmation *mJetKeeperMockAddHotConfirmation) Inspect(f func(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool)) *mJetKeeperMockAddHotConfirmation {
	if mmAddHotConfirmation.mock.inspectFuncAddHotConfirmation != nil {
		mmAddHotConfirmation.mock.t.Fatalf("Inspect function is already set for JetKeeperMock.AddHotConfirmation")
	}

	mmAddHotConfirmation.mock.inspectFuncAddHotConfirmation = f

	return mmAddHotConfirmation
}

// Return sets up results that will be returned by JetKeeper.AddHotConfirmation
func (mmAddHotConfirmation *mJetKeeperMockAddHotConfirmation) Return(err error) *JetKeeperMock {
	if mmAddHotConfirmation.mock.funcAddHotConfirmation != nil {
		mmAddHotConfirmation.mock.t.Fatalf("JetKeeperMock.AddHotConfirmation mock is already set by Set")
	}

	if mmAddHotConfirmation.defaultExpectation == nil {
		mmAddHotConfirmation.defaultExpectation = &JetKeeperMockAddHotConfirmationExpectation{mock: mmAddHotConfirmation.mock}
	}
	mmAddHotConfirmation.defaultExpectation.results = &JetKeeperMockAddHotConfirmationResults{err}
	return mmAddHotConfirmation.mock
}

//Set uses given function f to mock the JetKeeper.AddHotConfirmation method
func (mmAddHotConfirmation *mJetKeeperMockAddHotConfirmation) Set(f func(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) (err error)) *JetKeeperMock {
	if mmAddHotConfirmation.defaultExpectation != nil {
		mmAddHotConfirmation.mock.t.Fatalf("Default expectation is already set for the JetKeeper.AddHotConfirmation method")
	}

	if len(mmAddHotConfirmation.expectations) > 0 {
		mmAddHotConfirmation.mock.t.Fatalf("Some expectations are already set for the JetKeeper.AddHotConfirmation method")
	}

	mmAddHotConfirmation.mock.funcAddHotConfirmation = f
	return mmAddHotConfirmation.mock
}

// When sets expectation for the JetKeeper.AddHotConfirmation which will trigger the result defined by the following
// Then helper
func (mmAddHotConfirmation *mJetKeeperMockAddHotConfirmation) When(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) *JetKeeperMockAddHotConfirmationExpectation {
	if mmAddHotConfirmation.mock.funcAddHotConfirmation != nil {
		mmAddHotConfirmation.mock.t.Fatalf("JetKeeperMock.AddHotConfirmation mock is already set by Set")
	}

	expectation := &JetKeeperMockAddHotConfirmationExpectation{
		mock:   mmAddHotConfirmation.mock,
		params: &JetKeeperMockAddHotConfirmationParams{ctx, pn, jet, split},
	}
	mmAddHotConfirmation.expectations = append(mmAddHotConfirmation.expectations, expectation)
	return expectation
}

// Then sets up JetKeeper.AddHotConfirmation return parameters for the expectation previously defined by the When method
func (e *JetKeeperMockAddHotConfirmationExpectation) Then(err error) *JetKeeperMock {
	e.results = &JetKeeperMockAddHotConfirmationResults{err}
	return e.mock
}

// AddHotConfirmation implements JetKeeper
func (mmAddHotConfirmation *JetKeeperMock) AddHotConfirmation(ctx context.Context, pn insolar.PulseNumber, jet insolar.JetID, split bool) (err error) {
	mm_atomic.AddUint64(&mmAddHotConfirmation.beforeAddHotConfirmationCounter, 1)
	defer mm_atomic.AddUint64(&mmAddHotConfirmation.afterAddHotConfirmationCounter, 1)

	if mmAddHotConfirmation.inspectFuncAddHotConfirmation != nil {
		mmAddHotConfirmation.inspectFuncAddHotConfirmation(ctx, pn, jet, split)
	}

	mm_params := &JetKeeperMockAddHotConfirmationParams{ctx, pn, jet, split}

	// Record call args
	mmAddHotConfirmation.AddHotConfirmationMock.mutex.Lock()
	mmAddHotConfirmation.AddHotConfirmationMock.callArgs = append(mmAddHotConfirmation.AddHotConfirmationMock.callArgs, mm_params)
	mmAddHotConfirmation.AddHotConfirmationMock.mutex.Unlock()

	for _, e := range mmAddHotConfirmation.AddHotConfirmationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddHotConfirmation.AddHotConfirmationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddHotConfirmation.AddHotConfirmationMock.defaultExpectation.Counter, 1)
		mm_want := mmAddHotConfirmation.AddHotConfirmationMock.defaultExpectation.params
		mm_got := JetKeeperMockAddHotConfirmationParams{ctx, pn, jet, split}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddHotConfirmation.t.Errorf("JetKeeperMock.AddHotConfirmation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddHotConfirmation.AddHotConfirmationMock.defaultExpectation.results
		if mm_results == nil {
			mmAddHotConfirmation.t.Fatal("No results are set for the JetKeeperMock.AddHotConfirmation")
		}
		return (*mm_results).err
	}
	if mmAddHotConfirmation.funcAddHotConfirmation != nil {
		return mmAddHotConfirmation.funcAddHotConfirmation(ctx, pn, jet, split)
	}
	mmAddHotConfirmation.t.Fatalf("Unexpected call to JetKeeperMock.AddHotConfirmation. %v %v %v %v", ctx, pn, jet, split)
	return
}

// AddHotConfirmationAfterCounter returns a count of finished JetKeeperMock.AddHotConfirmation invocations
func (mmAddHotConfirmation *JetKeeperMock) AddHotConfirmationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddHotConfirmation.afterAddHotConfirmationCounter)
}

// AddHotConfirmationBeforeCounter returns a count of JetKeeperMock.AddHotConfirmation invocations
func (mmAddHotConfirmation *JetKeeperMock) AddHotConfirmationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddHotConfirmation.beforeAddHotConfirmationCounter)
}

// Calls returns a list of arguments used in each call to JetKeeperMock.AddHotConfirmation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddHotConfirmation *mJetKeeperMockAddHotConfirmation) Calls() []*JetKeeperMockAddHotConfirmationParams {
	mmAddHotConfirmation.mutex.RLock()

	argCopy := make([]*JetKeeperMockAddHotConfirmationParams, len(mmAddHotConfirmation.callArgs))
	copy(argCopy, mmAddHotConfirmation.callArgs)

	mmAddHotConfirmation.mutex.RUnlock()

	return argCopy
}

// MinimockAddHotConfirmationDone returns true if the count of the AddHotConfirmation invocations corresponds
// the number of defined expectations
func (m *JetKeeperMock) MinimockAddHotConfirmationDone() bool {
	for _, e := range m.AddHotConfirmationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddHotConfirmationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddHotConfirmationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddHotConfirmation != nil && mm_atomic.LoadUint64(&m.afterAddHotConfirmationCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddHotConfirmationInspect logs each unmet expectation
func (m *JetKeeperMock) MinimockAddHotConfirmationInspect() {
	for _, e := range m.AddHotConfirmationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JetKeeperMock.AddHotConfirmation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddHotConfirmationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddHotConfirmationCounter) < 1 {
		if m.AddHotConfirmationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to JetKeeperMock.AddHotConfirmation")
		} else {
			m.t.Errorf("Expected call to JetKeeperMock.AddHotConfirmation with params: %#v", *m.AddHotConfirmationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddHotConfirmation != nil && mm_atomic.LoadUint64(&m.afterAddHotConfirmationCounter) < 1 {
		m.t.Error("Expected call to JetKeeperMock.AddHotConfirmation")
	}
}

type mJetKeeperMockHasAllJetConfirms struct {
	mock               *JetKeeperMock
	defaultExpectation *JetKeeperMockHasAllJetConfirmsExpectation
	expectations       []*JetKeeperMockHasAllJetConfirmsExpectation

	callArgs []*JetKeeperMockHasAllJetConfirmsParams
	mutex    sync.RWMutex
}

// JetKeeperMockHasAllJetConfirmsExpectation specifies expectation struct of the JetKeeper.HasAllJetConfirms
type JetKeeperMockHasAllJetConfirmsExpectation struct {
	mock    *JetKeeperMock
	params  *JetKeeperMockHasAllJetConfirmsParams
	results *JetKeeperMockHasAllJetConfirmsResults
	Counter uint64
}

// JetKeeperMockHasAllJetConfirmsParams contains parameters of the JetKeeper.HasAllJetConfirms
type JetKeeperMockHasAllJetConfirmsParams struct {
	ctx context.Context
	pn  insolar.PulseNumber
}

// JetKeeperMockHasAllJetConfirmsResults contains results of the JetKeeper.HasAllJetConfirms
type JetKeeperMockHasAllJetConfirmsResults struct {
	b1 bool
}

// Expect sets up expected params for JetKeeper.HasAllJetConfirms
func (mmHasAllJetConfirms *mJetKeeperMockHasAllJetConfirms) Expect(ctx context.Context, pn insolar.PulseNumber) *mJetKeeperMockHasAllJetConfirms {
	if mmHasAllJetConfirms.mock.funcHasAllJetConfirms != nil {
		mmHasAllJetConfirms.mock.t.Fatalf("JetKeeperMock.HasAllJetConfirms mock is already set by Set")
	}

	if mmHasAllJetConfirms.defaultExpectation == nil {
		mmHasAllJetConfirms.defaultExpectation = &JetKeeperMockHasAllJetConfirmsExpectation{}
	}

	mmHasAllJetConfirms.defaultExpectation.params = &JetKeeperMockHasAllJetConfirmsParams{ctx, pn}
	for _, e := range mmHasAllJetConfirms.expectations {
		if minimock.Equal(e.params, mmHasAllJetConfirms.defaultExpectation.params) {
			mmHasAllJetConfirms.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHasAllJetConfirms.defaultExpectation.params)
		}
	}

	return mmHasAllJetConfirms
}

// Inspect accepts an inspector function that has same arguments as the JetKeeper.HasAllJetConfirms
func (mmHasAllJetConfirms *mJetKeeperMockHasAllJetConfirms) Inspect(f func(ctx context.Context, pn insolar.PulseNumber)) *mJetKeeperMockHasAllJetConfirms {
	if mmHasAllJetConfirms.mock.inspectFuncHasAllJetConfirms != nil {
		mmHasAllJetConfirms.mock.t.Fatalf("Inspect function is already set for JetKeeperMock.HasAllJetConfirms")
	}

	mmHasAllJetConfirms.mock.inspectFuncHasAllJetConfirms = f

	return mmHasAllJetConfirms
}

// Return sets up results that will be returned by JetKeeper.HasAllJetConfirms
func (mmHasAllJetConfirms *mJetKeeperMockHasAllJetConfirms) Return(b1 bool) *JetKeeperMock {
	if mmHasAllJetConfirms.mock.funcHasAllJetConfirms != nil {
		mmHasAllJetConfirms.mock.t.Fatalf("JetKeeperMock.HasAllJetConfirms mock is already set by Set")
	}

	if mmHasAllJetConfirms.defaultExpectation == nil {
		mmHasAllJetConfirms.defaultExpectation = &JetKeeperMockHasAllJetConfirmsExpectation{mock: mmHasAllJetConfirms.mock}
	}
	mmHasAllJetConfirms.defaultExpectation.results = &JetKeeperMockHasAllJetConfirmsResults{b1}
	return mmHasAllJetConfirms.mock
}

//Set uses given function f to mock the JetKeeper.HasAllJetConfirms method
func (mmHasAllJetConfirms *mJetKeeperMockHasAllJetConfirms) Set(f func(ctx context.Context, pn insolar.PulseNumber) (b1 bool)) *JetKeeperMock {
	if mmHasAllJetConfirms.defaultExpectation != nil {
		mmHasAllJetConfirms.mock.t.Fatalf("Default expectation is already set for the JetKeeper.HasAllJetConfirms method")
	}

	if len(mmHasAllJetConfirms.expectations) > 0 {
		mmHasAllJetConfirms.mock.t.Fatalf("Some expectations are already set for the JetKeeper.HasAllJetConfirms method")
	}

	mmHasAllJetConfirms.mock.funcHasAllJetConfirms = f
	return mmHasAllJetConfirms.mock
}

// When sets expectation for the JetKeeper.HasAllJetConfirms which will trigger the result defined by the following
// Then helper
func (mmHasAllJetConfirms *mJetKeeperMockHasAllJetConfirms) When(ctx context.Context, pn insolar.PulseNumber) *JetKeeperMockHasAllJetConfirmsExpectation {
	if mmHasAllJetConfirms.mock.funcHasAllJetConfirms != nil {
		mmHasAllJetConfirms.mock.t.Fatalf("JetKeeperMock.HasAllJetConfirms mock is already set by Set")
	}

	expectation := &JetKeeperMockHasAllJetConfirmsExpectation{
		mock:   mmHasAllJetConfirms.mock,
		params: &JetKeeperMockHasAllJetConfirmsParams{ctx, pn},
	}
	mmHasAllJetConfirms.expectations = append(mmHasAllJetConfirms.expectations, expectation)
	return expectation
}

// Then sets up JetKeeper.HasAllJetConfirms return parameters for the expectation previously defined by the When method
func (e *JetKeeperMockHasAllJetConfirmsExpectation) Then(b1 bool) *JetKeeperMock {
	e.results = &JetKeeperMockHasAllJetConfirmsResults{b1}
	return e.mock
}

// HasAllJetConfirms implements JetKeeper
func (mmHasAllJetConfirms *JetKeeperMock) HasAllJetConfirms(ctx context.Context, pn insolar.PulseNumber) (b1 bool) {
	mm_atomic.AddUint64(&mmHasAllJetConfirms.beforeHasAllJetConfirmsCounter, 1)
	defer mm_atomic.AddUint64(&mmHasAllJetConfirms.afterHasAllJetConfirmsCounter, 1)

	if mmHasAllJetConfirms.inspectFuncHasAllJetConfirms != nil {
		mmHasAllJetConfirms.inspectFuncHasAllJetConfirms(ctx, pn)
	}

	mm_params := &JetKeeperMockHasAllJetConfirmsParams{ctx, pn}

	// Record call args
	mmHasAllJetConfirms.HasAllJetConfirmsMock.mutex.Lock()
	mmHasAllJetConfirms.HasAllJetConfirmsMock.callArgs = append(mmHasAllJetConfirms.HasAllJetConfirmsMock.callArgs, mm_params)
	mmHasAllJetConfirms.HasAllJetConfirmsMock.mutex.Unlock()

	for _, e := range mmHasAllJetConfirms.HasAllJetConfirmsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmHasAllJetConfirms.HasAllJetConfirmsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHasAllJetConfirms.HasAllJetConfirmsMock.defaultExpectation.Counter, 1)
		mm_want := mmHasAllJetConfirms.HasAllJetConfirmsMock.defaultExpectation.params
		mm_got := JetKeeperMockHasAllJetConfirmsParams{ctx, pn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHasAllJetConfirms.t.Errorf("JetKeeperMock.HasAllJetConfirms got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHasAllJetConfirms.HasAllJetConfirmsMock.defaultExpectation.results
		if mm_results == nil {
			mmHasAllJetConfirms.t.Fatal("No results are set for the JetKeeperMock.HasAllJetConfirms")
		}
		return (*mm_results).b1
	}
	if mmHasAllJetConfirms.funcHasAllJetConfirms != nil {
		return mmHasAllJetConfirms.funcHasAllJetConfirms(ctx, pn)
	}
	mmHasAllJetConfirms.t.Fatalf("Unexpected call to JetKeeperMock.HasAllJetConfirms. %v %v", ctx, pn)
	return
}

// HasAllJetConfirmsAfterCounter returns a count of finished JetKeeperMock.HasAllJetConfirms invocations
func (mmHasAllJetConfirms *JetKeeperMock) HasAllJetConfirmsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasAllJetConfirms.afterHasAllJetConfirmsCounter)
}

// HasAllJetConfirmsBeforeCounter returns a count of JetKeeperMock.HasAllJetConfirms invocations
func (mmHasAllJetConfirms *JetKeeperMock) HasAllJetConfirmsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasAllJetConfirms.beforeHasAllJetConfirmsCounter)
}

// Calls returns a list of arguments used in each call to JetKeeperMock.HasAllJetConfirms.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHasAllJetConfirms *mJetKeeperMockHasAllJetConfirms) Calls() []*JetKeeperMockHasAllJetConfirmsParams {
	mmHasAllJetConfirms.mutex.RLock()

	argCopy := make([]*JetKeeperMockHasAllJetConfirmsParams, len(mmHasAllJetConfirms.callArgs))
	copy(argCopy, mmHasAllJetConfirms.callArgs)

	mmHasAllJetConfirms.mutex.RUnlock()

	return argCopy
}

// MinimockHasAllJetConfirmsDone returns true if the count of the HasAllJetConfirms invocations corresponds
// the number of defined expectations
func (m *JetKeeperMock) MinimockHasAllJetConfirmsDone() bool {
	for _, e := range m.HasAllJetConfirmsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasAllJetConfirmsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasAllJetConfirmsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasAllJetConfirms != nil && mm_atomic.LoadUint64(&m.afterHasAllJetConfirmsCounter) < 1 {
		return false
	}
	return true
}

// MinimockHasAllJetConfirmsInspect logs each unmet expectation
func (m *JetKeeperMock) MinimockHasAllJetConfirmsInspect() {
	for _, e := range m.HasAllJetConfirmsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JetKeeperMock.HasAllJetConfirms with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasAllJetConfirmsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasAllJetConfirmsCounter) < 1 {
		if m.HasAllJetConfirmsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to JetKeeperMock.HasAllJetConfirms")
		} else {
			m.t.Errorf("Expected call to JetKeeperMock.HasAllJetConfirms with params: %#v", *m.HasAllJetConfirmsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasAllJetConfirms != nil && mm_atomic.LoadUint64(&m.afterHasAllJetConfirmsCounter) < 1 {
		m.t.Error("Expected call to JetKeeperMock.HasAllJetConfirms")
	}
}

type mJetKeeperMockStorage struct {
	mock               *JetKeeperMock
	defaultExpectation *JetKeeperMockStorageExpectation
	expectations       []*JetKeeperMockStorageExpectation
}

// JetKeeperMockStorageExpectation specifies expectation struct of the JetKeeper.Storage
type JetKeeperMockStorageExpectation struct {
	mock *JetKeeperMock

	results *JetKeeperMockStorageResults
	Counter uint64
}

// JetKeeperMockStorageResults contains results of the JetKeeper.Storage
type JetKeeperMockStorageResults struct {
	s1 jet.Storage
}

// Expect sets up expected params for JetKeeper.Storage
func (mmStorage *mJetKeeperMockStorage) Expect() *mJetKeeperMockStorage {
	if mmStorage.mock.funcStorage != nil {
		mmStorage.mock.t.Fatalf("JetKeeperMock.Storage mock is already set by Set")
	}

	if mmStorage.defaultExpectation == nil {
		mmStorage.defaultExpectation = &JetKeeperMockStorageExpectation{}
	}

	return mmStorage
}

// Inspect accepts an inspector function that has same arguments as the JetKeeper.Storage
func (mmStorage *mJetKeeperMockStorage) Inspect(f func()) *mJetKeeperMockStorage {
	if mmStorage.mock.inspectFuncStorage != nil {
		mmStorage.mock.t.Fatalf("Inspect function is already set for JetKeeperMock.Storage")
	}

	mmStorage.mock.inspectFuncStorage = f

	return mmStorage
}

// Return sets up results that will be returned by JetKeeper.Storage
func (mmStorage *mJetKeeperMockStorage) Return(s1 jet.Storage) *JetKeeperMock {
	if mmStorage.mock.funcStorage != nil {
		mmStorage.mock.t.Fatalf("JetKeeperMock.Storage mock is already set by Set")
	}

	if mmStorage.defaultExpectation == nil {
		mmStorage.defaultExpectation = &JetKeeperMockStorageExpectation{mock: mmStorage.mock}
	}
	mmStorage.defaultExpectation.results = &JetKeeperMockStorageResults{s1}
	return mmStorage.mock
}

//Set uses given function f to mock the JetKeeper.Storage method
func (mmStorage *mJetKeeperMockStorage) Set(f func() (s1 jet.Storage)) *JetKeeperMock {
	if mmStorage.defaultExpectation != nil {
		mmStorage.mock.t.Fatalf("Default expectation is already set for the JetKeeper.Storage method")
	}

	if len(mmStorage.expectations) > 0 {
		mmStorage.mock.t.Fatalf("Some expectations are already set for the JetKeeper.Storage method")
	}

	mmStorage.mock.funcStorage = f
	return mmStorage.mock
}

// Storage implements JetKeeper
func (mmStorage *JetKeeperMock) Storage() (s1 jet.Storage) {
	mm_atomic.AddUint64(&mmStorage.beforeStorageCounter, 1)
	defer mm_atomic.AddUint64(&mmStorage.afterStorageCounter, 1)

	if mmStorage.inspectFuncStorage != nil {
		mmStorage.inspectFuncStorage()
	}

	if mmStorage.StorageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStorage.StorageMock.defaultExpectation.Counter, 1)

		mm_results := mmStorage.StorageMock.defaultExpectation.results
		if mm_results == nil {
			mmStorage.t.Fatal("No results are set for the JetKeeperMock.Storage")
		}
		return (*mm_results).s1
	}
	if mmStorage.funcStorage != nil {
		return mmStorage.funcStorage()
	}
	mmStorage.t.Fatalf("Unexpected call to JetKeeperMock.Storage.")
	return
}

// StorageAfterCounter returns a count of finished JetKeeperMock.Storage invocations
func (mmStorage *JetKeeperMock) StorageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStorage.afterStorageCounter)
}

// StorageBeforeCounter returns a count of JetKeeperMock.Storage invocations
func (mmStorage *JetKeeperMock) StorageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStorage.beforeStorageCounter)
}

// MinimockStorageDone returns true if the count of the Storage invocations corresponds
// the number of defined expectations
func (m *JetKeeperMock) MinimockStorageDone() bool {
	for _, e := range m.StorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StorageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStorageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStorage != nil && mm_atomic.LoadUint64(&m.afterStorageCounter) < 1 {
		return false
	}
	return true
}

// MinimockStorageInspect logs each unmet expectation
func (m *JetKeeperMock) MinimockStorageInspect() {
	for _, e := range m.StorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JetKeeperMock.Storage")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StorageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStorageCounter) < 1 {
		m.t.Error("Expected call to JetKeeperMock.Storage")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStorage != nil && mm_atomic.LoadUint64(&m.afterStorageCounter) < 1 {
		m.t.Error("Expected call to JetKeeperMock.Storage")
	}
}

type mJetKeeperMockTopSyncPulse struct {
	mock               *JetKeeperMock
	defaultExpectation *JetKeeperMockTopSyncPulseExpectation
	expectations       []*JetKeeperMockTopSyncPulseExpectation
}

// JetKeeperMockTopSyncPulseExpectation specifies expectation struct of the JetKeeper.TopSyncPulse
type JetKeeperMockTopSyncPulseExpectation struct {
	mock *JetKeeperMock

	results *JetKeeperMockTopSyncPulseResults
	Counter uint64
}

// JetKeeperMockTopSyncPulseResults contains results of the JetKeeper.TopSyncPulse
type JetKeeperMockTopSyncPulseResults struct {
	p1 insolar.PulseNumber
}

// Expect sets up expected params for JetKeeper.TopSyncPulse
func (mmTopSyncPulse *mJetKeeperMockTopSyncPulse) Expect() *mJetKeeperMockTopSyncPulse {
	if mmTopSyncPulse.mock.funcTopSyncPulse != nil {
		mmTopSyncPulse.mock.t.Fatalf("JetKeeperMock.TopSyncPulse mock is already set by Set")
	}

	if mmTopSyncPulse.defaultExpectation == nil {
		mmTopSyncPulse.defaultExpectation = &JetKeeperMockTopSyncPulseExpectation{}
	}

	return mmTopSyncPulse
}

// Inspect accepts an inspector function that has same arguments as the JetKeeper.TopSyncPulse
func (mmTopSyncPulse *mJetKeeperMockTopSyncPulse) Inspect(f func()) *mJetKeeperMockTopSyncPulse {
	if mmTopSyncPulse.mock.inspectFuncTopSyncPulse != nil {
		mmTopSyncPulse.mock.t.Fatalf("Inspect function is already set for JetKeeperMock.TopSyncPulse")
	}

	mmTopSyncPulse.mock.inspectFuncTopSyncPulse = f

	return mmTopSyncPulse
}

// Return sets up results that will be returned by JetKeeper.TopSyncPulse
func (mmTopSyncPulse *mJetKeeperMockTopSyncPulse) Return(p1 insolar.PulseNumber) *JetKeeperMock {
	if mmTopSyncPulse.mock.funcTopSyncPulse != nil {
		mmTopSyncPulse.mock.t.Fatalf("JetKeeperMock.TopSyncPulse mock is already set by Set")
	}

	if mmTopSyncPulse.defaultExpectation == nil {
		mmTopSyncPulse.defaultExpectation = &JetKeeperMockTopSyncPulseExpectation{mock: mmTopSyncPulse.mock}
	}
	mmTopSyncPulse.defaultExpectation.results = &JetKeeperMockTopSyncPulseResults{p1}
	return mmTopSyncPulse.mock
}

//Set uses given function f to mock the JetKeeper.TopSyncPulse method
func (mmTopSyncPulse *mJetKeeperMockTopSyncPulse) Set(f func() (p1 insolar.PulseNumber)) *JetKeeperMock {
	if mmTopSyncPulse.defaultExpectation != nil {
		mmTopSyncPulse.mock.t.Fatalf("Default expectation is already set for the JetKeeper.TopSyncPulse method")
	}

	if len(mmTopSyncPulse.expectations) > 0 {
		mmTopSyncPulse.mock.t.Fatalf("Some expectations are already set for the JetKeeper.TopSyncPulse method")
	}

	mmTopSyncPulse.mock.funcTopSyncPulse = f
	return mmTopSyncPulse.mock
}

// TopSyncPulse implements JetKeeper
func (mmTopSyncPulse *JetKeeperMock) TopSyncPulse() (p1 insolar.PulseNumber) {
	mm_atomic.AddUint64(&mmTopSyncPulse.beforeTopSyncPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmTopSyncPulse.afterTopSyncPulseCounter, 1)

	if mmTopSyncPulse.inspectFuncTopSyncPulse != nil {
		mmTopSyncPulse.inspectFuncTopSyncPulse()
	}

	if mmTopSyncPulse.TopSyncPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTopSyncPulse.TopSyncPulseMock.defaultExpectation.Counter, 1)

		mm_results := mmTopSyncPulse.TopSyncPulseMock.defaultExpectation.results
		if mm_results == nil {
			mmTopSyncPulse.t.Fatal("No results are set for the JetKeeperMock.TopSyncPulse")
		}
		return (*mm_results).p1
	}
	if mmTopSyncPulse.funcTopSyncPulse != nil {
		return mmTopSyncPulse.funcTopSyncPulse()
	}
	mmTopSyncPulse.t.Fatalf("Unexpected call to JetKeeperMock.TopSyncPulse.")
	return
}

// TopSyncPulseAfterCounter returns a count of finished JetKeeperMock.TopSyncPulse invocations
func (mmTopSyncPulse *JetKeeperMock) TopSyncPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTopSyncPulse.afterTopSyncPulseCounter)
}

// TopSyncPulseBeforeCounter returns a count of JetKeeperMock.TopSyncPulse invocations
func (mmTopSyncPulse *JetKeeperMock) TopSyncPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTopSyncPulse.beforeTopSyncPulseCounter)
}

// MinimockTopSyncPulseDone returns true if the count of the TopSyncPulse invocations corresponds
// the number of defined expectations
func (m *JetKeeperMock) MinimockTopSyncPulseDone() bool {
	for _, e := range m.TopSyncPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TopSyncPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTopSyncPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTopSyncPulse != nil && mm_atomic.LoadUint64(&m.afterTopSyncPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockTopSyncPulseInspect logs each unmet expectation
func (m *JetKeeperMock) MinimockTopSyncPulseInspect() {
	for _, e := range m.TopSyncPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JetKeeperMock.TopSyncPulse")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TopSyncPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTopSyncPulseCounter) < 1 {
		m.t.Error("Expected call to JetKeeperMock.TopSyncPulse")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTopSyncPulse != nil && mm_atomic.LoadUint64(&m.afterTopSyncPulseCounter) < 1 {
		m.t.Error("Expected call to JetKeeperMock.TopSyncPulse")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *JetKeeperMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddBackupConfirmationInspect()

		m.MinimockAddDropConfirmationInspect()

		m.MinimockAddHotConfirmationInspect()

		m.MinimockHasAllJetConfirmsInspect()

		m.MinimockStorageInspect()

		m.MinimockTopSyncPulseInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *JetKeeperMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *JetKeeperMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddBackupConfirmationDone() &&
		m.MinimockAddDropConfirmationDone() &&
		m.MinimockAddHotConfirmationDone() &&
		m.MinimockHasAllJetConfirmsDone() &&
		m.MinimockStorageDone() &&
		m.MinimockTopSyncPulseDone()
}
