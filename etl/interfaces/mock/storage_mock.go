package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/block-explorer/etl/models"
)

// StorageMock implements interfaces.Storage
type StorageMock struct {
	t minimock.Tester

	funcCompletePulse          func(pulseNumber int64) (err error)
	inspectFuncCompletePulse   func(pulseNumber int64)
	afterCompletePulseCounter  uint64
	beforeCompletePulseCounter uint64
	CompletePulseMock          mStorageMockCompletePulse

	funcGetIncompletePulses          func() (pa1 []models.Pulse, err error)
	inspectFuncGetIncompletePulses   func()
	afterGetIncompletePulsesCounter  uint64
	beforeGetIncompletePulsesCounter uint64
	GetIncompletePulsesMock          mStorageMockGetIncompletePulses

	funcGetJetDrops          func(pulse models.Pulse) (ja1 []models.JetDrop, err error)
	inspectFuncGetJetDrops   func(pulse models.Pulse)
	afterGetJetDropsCounter  uint64
	beforeGetJetDropsCounter uint64
	GetJetDropsMock          mStorageMockGetJetDrops

	funcGetNextSavedPulse          func(fromPulseNumber models.Pulse, completedOnly bool) (p1 models.Pulse, err error)
	inspectFuncGetNextSavedPulse   func(fromPulseNumber models.Pulse, completedOnly bool)
	afterGetNextSavedPulseCounter  uint64
	beforeGetNextSavedPulseCounter uint64
	GetNextSavedPulseMock          mStorageMockGetNextSavedPulse

	funcGetPulseByPrev          func(prevPulse models.Pulse) (p1 models.Pulse, err error)
	inspectFuncGetPulseByPrev   func(prevPulse models.Pulse)
	afterGetPulseByPrevCounter  uint64
	beforeGetPulseByPrevCounter uint64
	GetPulseByPrevMock          mStorageMockGetPulseByPrev

	funcGetSequentialPulse          func() (p1 models.Pulse, err error)
	inspectFuncGetSequentialPulse   func()
	afterGetSequentialPulseCounter  uint64
	beforeGetSequentialPulseCounter uint64
	GetSequentialPulseMock          mStorageMockGetSequentialPulse

	funcSaveJetDropData          func(jetDrop models.JetDrop, records []models.Record, pulseNumber int64) (err error)
	inspectFuncSaveJetDropData   func(jetDrop models.JetDrop, records []models.Record, pulseNumber int64)
	afterSaveJetDropDataCounter  uint64
	beforeSaveJetDropDataCounter uint64
	SaveJetDropDataMock          mStorageMockSaveJetDropData

	funcSavePulse          func(pulse models.Pulse) (err error)
	inspectFuncSavePulse   func(pulse models.Pulse)
	afterSavePulseCounter  uint64
	beforeSavePulseCounter uint64
	SavePulseMock          mStorageMockSavePulse

	funcSequencePulse          func(pulseNumber int64) (err error)
	inspectFuncSequencePulse   func(pulseNumber int64)
	afterSequencePulseCounter  uint64
	beforeSequencePulseCounter uint64
	SequencePulseMock          mStorageMockSequencePulse
}

// NewStorageMock returns a mock for interfaces.Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CompletePulseMock = mStorageMockCompletePulse{mock: m}
	m.CompletePulseMock.callArgs = []*StorageMockCompletePulseParams{}

	m.GetIncompletePulsesMock = mStorageMockGetIncompletePulses{mock: m}

	m.GetJetDropsMock = mStorageMockGetJetDrops{mock: m}
	m.GetJetDropsMock.callArgs = []*StorageMockGetJetDropsParams{}

	m.GetNextSavedPulseMock = mStorageMockGetNextSavedPulse{mock: m}
	m.GetNextSavedPulseMock.callArgs = []*StorageMockGetNextSavedPulseParams{}

	m.GetPulseByPrevMock = mStorageMockGetPulseByPrev{mock: m}
	m.GetPulseByPrevMock.callArgs = []*StorageMockGetPulseByPrevParams{}

	m.GetSequentialPulseMock = mStorageMockGetSequentialPulse{mock: m}

	m.SaveJetDropDataMock = mStorageMockSaveJetDropData{mock: m}
	m.SaveJetDropDataMock.callArgs = []*StorageMockSaveJetDropDataParams{}

	m.SavePulseMock = mStorageMockSavePulse{mock: m}
	m.SavePulseMock.callArgs = []*StorageMockSavePulseParams{}

	m.SequencePulseMock = mStorageMockSequencePulse{mock: m}
	m.SequencePulseMock.callArgs = []*StorageMockSequencePulseParams{}

	return m
}

type mStorageMockCompletePulse struct {
	mock               *StorageMock
	defaultExpectation *StorageMockCompletePulseExpectation
	expectations       []*StorageMockCompletePulseExpectation

	callArgs []*StorageMockCompletePulseParams
	mutex    sync.RWMutex
}

// StorageMockCompletePulseExpectation specifies expectation struct of the Storage.CompletePulse
type StorageMockCompletePulseExpectation struct {
	mock    *StorageMock
	params  *StorageMockCompletePulseParams
	results *StorageMockCompletePulseResults
	Counter uint64
}

// StorageMockCompletePulseParams contains parameters of the Storage.CompletePulse
type StorageMockCompletePulseParams struct {
	pulseNumber int64
}

// StorageMockCompletePulseResults contains results of the Storage.CompletePulse
type StorageMockCompletePulseResults struct {
	err error
}

// Expect sets up expected params for Storage.CompletePulse
func (mmCompletePulse *mStorageMockCompletePulse) Expect(pulseNumber int64) *mStorageMockCompletePulse {
	if mmCompletePulse.mock.funcCompletePulse != nil {
		mmCompletePulse.mock.t.Fatalf("StorageMock.CompletePulse mock is already set by Set")
	}

	if mmCompletePulse.defaultExpectation == nil {
		mmCompletePulse.defaultExpectation = &StorageMockCompletePulseExpectation{}
	}

	mmCompletePulse.defaultExpectation.params = &StorageMockCompletePulseParams{pulseNumber}
	for _, e := range mmCompletePulse.expectations {
		if minimock.Equal(e.params, mmCompletePulse.defaultExpectation.params) {
			mmCompletePulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCompletePulse.defaultExpectation.params)
		}
	}

	return mmCompletePulse
}

// Inspect accepts an inspector function that has same arguments as the Storage.CompletePulse
func (mmCompletePulse *mStorageMockCompletePulse) Inspect(f func(pulseNumber int64)) *mStorageMockCompletePulse {
	if mmCompletePulse.mock.inspectFuncCompletePulse != nil {
		mmCompletePulse.mock.t.Fatalf("Inspect function is already set for StorageMock.CompletePulse")
	}

	mmCompletePulse.mock.inspectFuncCompletePulse = f

	return mmCompletePulse
}

// Return sets up results that will be returned by Storage.CompletePulse
func (mmCompletePulse *mStorageMockCompletePulse) Return(err error) *StorageMock {
	if mmCompletePulse.mock.funcCompletePulse != nil {
		mmCompletePulse.mock.t.Fatalf("StorageMock.CompletePulse mock is already set by Set")
	}

	if mmCompletePulse.defaultExpectation == nil {
		mmCompletePulse.defaultExpectation = &StorageMockCompletePulseExpectation{mock: mmCompletePulse.mock}
	}
	mmCompletePulse.defaultExpectation.results = &StorageMockCompletePulseResults{err}
	return mmCompletePulse.mock
}

//Set uses given function f to mock the Storage.CompletePulse method
func (mmCompletePulse *mStorageMockCompletePulse) Set(f func(pulseNumber int64) (err error)) *StorageMock {
	if mmCompletePulse.defaultExpectation != nil {
		mmCompletePulse.mock.t.Fatalf("Default expectation is already set for the Storage.CompletePulse method")
	}

	if len(mmCompletePulse.expectations) > 0 {
		mmCompletePulse.mock.t.Fatalf("Some expectations are already set for the Storage.CompletePulse method")
	}

	mmCompletePulse.mock.funcCompletePulse = f
	return mmCompletePulse.mock
}

// When sets expectation for the Storage.CompletePulse which will trigger the result defined by the following
// Then helper
func (mmCompletePulse *mStorageMockCompletePulse) When(pulseNumber int64) *StorageMockCompletePulseExpectation {
	if mmCompletePulse.mock.funcCompletePulse != nil {
		mmCompletePulse.mock.t.Fatalf("StorageMock.CompletePulse mock is already set by Set")
	}

	expectation := &StorageMockCompletePulseExpectation{
		mock:   mmCompletePulse.mock,
		params: &StorageMockCompletePulseParams{pulseNumber},
	}
	mmCompletePulse.expectations = append(mmCompletePulse.expectations, expectation)
	return expectation
}

// Then sets up Storage.CompletePulse return parameters for the expectation previously defined by the When method
func (e *StorageMockCompletePulseExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockCompletePulseResults{err}
	return e.mock
}

// CompletePulse implements interfaces.Storage
func (mmCompletePulse *StorageMock) CompletePulse(pulseNumber int64) (err error) {
	mm_atomic.AddUint64(&mmCompletePulse.beforeCompletePulseCounter, 1)
	defer mm_atomic.AddUint64(&mmCompletePulse.afterCompletePulseCounter, 1)

	if mmCompletePulse.inspectFuncCompletePulse != nil {
		mmCompletePulse.inspectFuncCompletePulse(pulseNumber)
	}

	mm_params := &StorageMockCompletePulseParams{pulseNumber}

	// Record call args
	mmCompletePulse.CompletePulseMock.mutex.Lock()
	mmCompletePulse.CompletePulseMock.callArgs = append(mmCompletePulse.CompletePulseMock.callArgs, mm_params)
	mmCompletePulse.CompletePulseMock.mutex.Unlock()

	for _, e := range mmCompletePulse.CompletePulseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCompletePulse.CompletePulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCompletePulse.CompletePulseMock.defaultExpectation.Counter, 1)
		mm_want := mmCompletePulse.CompletePulseMock.defaultExpectation.params
		mm_got := StorageMockCompletePulseParams{pulseNumber}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCompletePulse.t.Errorf("StorageMock.CompletePulse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCompletePulse.CompletePulseMock.defaultExpectation.results
		if mm_results == nil {
			mmCompletePulse.t.Fatal("No results are set for the StorageMock.CompletePulse")
		}
		return (*mm_results).err
	}
	if mmCompletePulse.funcCompletePulse != nil {
		return mmCompletePulse.funcCompletePulse(pulseNumber)
	}
	mmCompletePulse.t.Fatalf("Unexpected call to StorageMock.CompletePulse. %v", pulseNumber)
	return
}

// CompletePulseAfterCounter returns a count of finished StorageMock.CompletePulse invocations
func (mmCompletePulse *StorageMock) CompletePulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompletePulse.afterCompletePulseCounter)
}

// CompletePulseBeforeCounter returns a count of StorageMock.CompletePulse invocations
func (mmCompletePulse *StorageMock) CompletePulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompletePulse.beforeCompletePulseCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.CompletePulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCompletePulse *mStorageMockCompletePulse) Calls() []*StorageMockCompletePulseParams {
	mmCompletePulse.mutex.RLock()

	argCopy := make([]*StorageMockCompletePulseParams, len(mmCompletePulse.callArgs))
	copy(argCopy, mmCompletePulse.callArgs)

	mmCompletePulse.mutex.RUnlock()

	return argCopy
}

// MinimockCompletePulseDone returns true if the count of the CompletePulse invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCompletePulseDone() bool {
	for _, e := range m.CompletePulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CompletePulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCompletePulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompletePulse != nil && mm_atomic.LoadUint64(&m.afterCompletePulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCompletePulseInspect logs each unmet expectation
func (m *StorageMock) MinimockCompletePulseInspect() {
	for _, e := range m.CompletePulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.CompletePulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CompletePulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCompletePulseCounter) < 1 {
		if m.CompletePulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.CompletePulse")
		} else {
			m.t.Errorf("Expected call to StorageMock.CompletePulse with params: %#v", *m.CompletePulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompletePulse != nil && mm_atomic.LoadUint64(&m.afterCompletePulseCounter) < 1 {
		m.t.Error("Expected call to StorageMock.CompletePulse")
	}
}

type mStorageMockGetIncompletePulses struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetIncompletePulsesExpectation
	expectations       []*StorageMockGetIncompletePulsesExpectation
}

// StorageMockGetIncompletePulsesExpectation specifies expectation struct of the Storage.GetIncompletePulses
type StorageMockGetIncompletePulsesExpectation struct {
	mock *StorageMock

	results *StorageMockGetIncompletePulsesResults
	Counter uint64
}

// StorageMockGetIncompletePulsesResults contains results of the Storage.GetIncompletePulses
type StorageMockGetIncompletePulsesResults struct {
	pa1 []models.Pulse
	err error
}

// Expect sets up expected params for Storage.GetIncompletePulses
func (mmGetIncompletePulses *mStorageMockGetIncompletePulses) Expect() *mStorageMockGetIncompletePulses {
	if mmGetIncompletePulses.mock.funcGetIncompletePulses != nil {
		mmGetIncompletePulses.mock.t.Fatalf("StorageMock.GetIncompletePulses mock is already set by Set")
	}

	if mmGetIncompletePulses.defaultExpectation == nil {
		mmGetIncompletePulses.defaultExpectation = &StorageMockGetIncompletePulsesExpectation{}
	}

	return mmGetIncompletePulses
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetIncompletePulses
func (mmGetIncompletePulses *mStorageMockGetIncompletePulses) Inspect(f func()) *mStorageMockGetIncompletePulses {
	if mmGetIncompletePulses.mock.inspectFuncGetIncompletePulses != nil {
		mmGetIncompletePulses.mock.t.Fatalf("Inspect function is already set for StorageMock.GetIncompletePulses")
	}

	mmGetIncompletePulses.mock.inspectFuncGetIncompletePulses = f

	return mmGetIncompletePulses
}

// Return sets up results that will be returned by Storage.GetIncompletePulses
func (mmGetIncompletePulses *mStorageMockGetIncompletePulses) Return(pa1 []models.Pulse, err error) *StorageMock {
	if mmGetIncompletePulses.mock.funcGetIncompletePulses != nil {
		mmGetIncompletePulses.mock.t.Fatalf("StorageMock.GetIncompletePulses mock is already set by Set")
	}

	if mmGetIncompletePulses.defaultExpectation == nil {
		mmGetIncompletePulses.defaultExpectation = &StorageMockGetIncompletePulsesExpectation{mock: mmGetIncompletePulses.mock}
	}
	mmGetIncompletePulses.defaultExpectation.results = &StorageMockGetIncompletePulsesResults{pa1, err}
	return mmGetIncompletePulses.mock
}

//Set uses given function f to mock the Storage.GetIncompletePulses method
func (mmGetIncompletePulses *mStorageMockGetIncompletePulses) Set(f func() (pa1 []models.Pulse, err error)) *StorageMock {
	if mmGetIncompletePulses.defaultExpectation != nil {
		mmGetIncompletePulses.mock.t.Fatalf("Default expectation is already set for the Storage.GetIncompletePulses method")
	}

	if len(mmGetIncompletePulses.expectations) > 0 {
		mmGetIncompletePulses.mock.t.Fatalf("Some expectations are already set for the Storage.GetIncompletePulses method")
	}

	mmGetIncompletePulses.mock.funcGetIncompletePulses = f
	return mmGetIncompletePulses.mock
}

// GetIncompletePulses implements interfaces.Storage
func (mmGetIncompletePulses *StorageMock) GetIncompletePulses() (pa1 []models.Pulse, err error) {
	mm_atomic.AddUint64(&mmGetIncompletePulses.beforeGetIncompletePulsesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetIncompletePulses.afterGetIncompletePulsesCounter, 1)

	if mmGetIncompletePulses.inspectFuncGetIncompletePulses != nil {
		mmGetIncompletePulses.inspectFuncGetIncompletePulses()
	}

	if mmGetIncompletePulses.GetIncompletePulsesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetIncompletePulses.GetIncompletePulsesMock.defaultExpectation.Counter, 1)

		mm_results := mmGetIncompletePulses.GetIncompletePulsesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetIncompletePulses.t.Fatal("No results are set for the StorageMock.GetIncompletePulses")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetIncompletePulses.funcGetIncompletePulses != nil {
		return mmGetIncompletePulses.funcGetIncompletePulses()
	}
	mmGetIncompletePulses.t.Fatalf("Unexpected call to StorageMock.GetIncompletePulses.")
	return
}

// GetIncompletePulsesAfterCounter returns a count of finished StorageMock.GetIncompletePulses invocations
func (mmGetIncompletePulses *StorageMock) GetIncompletePulsesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIncompletePulses.afterGetIncompletePulsesCounter)
}

// GetIncompletePulsesBeforeCounter returns a count of StorageMock.GetIncompletePulses invocations
func (mmGetIncompletePulses *StorageMock) GetIncompletePulsesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIncompletePulses.beforeGetIncompletePulsesCounter)
}

// MinimockGetIncompletePulsesDone returns true if the count of the GetIncompletePulses invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetIncompletePulsesDone() bool {
	for _, e := range m.GetIncompletePulsesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetIncompletePulsesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetIncompletePulsesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIncompletePulses != nil && mm_atomic.LoadUint64(&m.afterGetIncompletePulsesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetIncompletePulsesInspect logs each unmet expectation
func (m *StorageMock) MinimockGetIncompletePulsesInspect() {
	for _, e := range m.GetIncompletePulsesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.GetIncompletePulses")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetIncompletePulsesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetIncompletePulsesCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetIncompletePulses")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIncompletePulses != nil && mm_atomic.LoadUint64(&m.afterGetIncompletePulsesCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetIncompletePulses")
	}
}

type mStorageMockGetJetDrops struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetJetDropsExpectation
	expectations       []*StorageMockGetJetDropsExpectation

	callArgs []*StorageMockGetJetDropsParams
	mutex    sync.RWMutex
}

// StorageMockGetJetDropsExpectation specifies expectation struct of the Storage.GetJetDrops
type StorageMockGetJetDropsExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetJetDropsParams
	results *StorageMockGetJetDropsResults
	Counter uint64
}

// StorageMockGetJetDropsParams contains parameters of the Storage.GetJetDrops
type StorageMockGetJetDropsParams struct {
	pulse models.Pulse
}

// StorageMockGetJetDropsResults contains results of the Storage.GetJetDrops
type StorageMockGetJetDropsResults struct {
	ja1 []models.JetDrop
	err error
}

// Expect sets up expected params for Storage.GetJetDrops
func (mmGetJetDrops *mStorageMockGetJetDrops) Expect(pulse models.Pulse) *mStorageMockGetJetDrops {
	if mmGetJetDrops.mock.funcGetJetDrops != nil {
		mmGetJetDrops.mock.t.Fatalf("StorageMock.GetJetDrops mock is already set by Set")
	}

	if mmGetJetDrops.defaultExpectation == nil {
		mmGetJetDrops.defaultExpectation = &StorageMockGetJetDropsExpectation{}
	}

	mmGetJetDrops.defaultExpectation.params = &StorageMockGetJetDropsParams{pulse}
	for _, e := range mmGetJetDrops.expectations {
		if minimock.Equal(e.params, mmGetJetDrops.defaultExpectation.params) {
			mmGetJetDrops.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetJetDrops.defaultExpectation.params)
		}
	}

	return mmGetJetDrops
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetJetDrops
func (mmGetJetDrops *mStorageMockGetJetDrops) Inspect(f func(pulse models.Pulse)) *mStorageMockGetJetDrops {
	if mmGetJetDrops.mock.inspectFuncGetJetDrops != nil {
		mmGetJetDrops.mock.t.Fatalf("Inspect function is already set for StorageMock.GetJetDrops")
	}

	mmGetJetDrops.mock.inspectFuncGetJetDrops = f

	return mmGetJetDrops
}

// Return sets up results that will be returned by Storage.GetJetDrops
func (mmGetJetDrops *mStorageMockGetJetDrops) Return(ja1 []models.JetDrop, err error) *StorageMock {
	if mmGetJetDrops.mock.funcGetJetDrops != nil {
		mmGetJetDrops.mock.t.Fatalf("StorageMock.GetJetDrops mock is already set by Set")
	}

	if mmGetJetDrops.defaultExpectation == nil {
		mmGetJetDrops.defaultExpectation = &StorageMockGetJetDropsExpectation{mock: mmGetJetDrops.mock}
	}
	mmGetJetDrops.defaultExpectation.results = &StorageMockGetJetDropsResults{ja1, err}
	return mmGetJetDrops.mock
}

//Set uses given function f to mock the Storage.GetJetDrops method
func (mmGetJetDrops *mStorageMockGetJetDrops) Set(f func(pulse models.Pulse) (ja1 []models.JetDrop, err error)) *StorageMock {
	if mmGetJetDrops.defaultExpectation != nil {
		mmGetJetDrops.mock.t.Fatalf("Default expectation is already set for the Storage.GetJetDrops method")
	}

	if len(mmGetJetDrops.expectations) > 0 {
		mmGetJetDrops.mock.t.Fatalf("Some expectations are already set for the Storage.GetJetDrops method")
	}

	mmGetJetDrops.mock.funcGetJetDrops = f
	return mmGetJetDrops.mock
}

// When sets expectation for the Storage.GetJetDrops which will trigger the result defined by the following
// Then helper
func (mmGetJetDrops *mStorageMockGetJetDrops) When(pulse models.Pulse) *StorageMockGetJetDropsExpectation {
	if mmGetJetDrops.mock.funcGetJetDrops != nil {
		mmGetJetDrops.mock.t.Fatalf("StorageMock.GetJetDrops mock is already set by Set")
	}

	expectation := &StorageMockGetJetDropsExpectation{
		mock:   mmGetJetDrops.mock,
		params: &StorageMockGetJetDropsParams{pulse},
	}
	mmGetJetDrops.expectations = append(mmGetJetDrops.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetJetDrops return parameters for the expectation previously defined by the When method
func (e *StorageMockGetJetDropsExpectation) Then(ja1 []models.JetDrop, err error) *StorageMock {
	e.results = &StorageMockGetJetDropsResults{ja1, err}
	return e.mock
}

// GetJetDrops implements interfaces.Storage
func (mmGetJetDrops *StorageMock) GetJetDrops(pulse models.Pulse) (ja1 []models.JetDrop, err error) {
	mm_atomic.AddUint64(&mmGetJetDrops.beforeGetJetDropsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetJetDrops.afterGetJetDropsCounter, 1)

	if mmGetJetDrops.inspectFuncGetJetDrops != nil {
		mmGetJetDrops.inspectFuncGetJetDrops(pulse)
	}

	mm_params := &StorageMockGetJetDropsParams{pulse}

	// Record call args
	mmGetJetDrops.GetJetDropsMock.mutex.Lock()
	mmGetJetDrops.GetJetDropsMock.callArgs = append(mmGetJetDrops.GetJetDropsMock.callArgs, mm_params)
	mmGetJetDrops.GetJetDropsMock.mutex.Unlock()

	for _, e := range mmGetJetDrops.GetJetDropsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ja1, e.results.err
		}
	}

	if mmGetJetDrops.GetJetDropsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetJetDrops.GetJetDropsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetJetDrops.GetJetDropsMock.defaultExpectation.params
		mm_got := StorageMockGetJetDropsParams{pulse}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetJetDrops.t.Errorf("StorageMock.GetJetDrops got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetJetDrops.GetJetDropsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetJetDrops.t.Fatal("No results are set for the StorageMock.GetJetDrops")
		}
		return (*mm_results).ja1, (*mm_results).err
	}
	if mmGetJetDrops.funcGetJetDrops != nil {
		return mmGetJetDrops.funcGetJetDrops(pulse)
	}
	mmGetJetDrops.t.Fatalf("Unexpected call to StorageMock.GetJetDrops. %v", pulse)
	return
}

// GetJetDropsAfterCounter returns a count of finished StorageMock.GetJetDrops invocations
func (mmGetJetDrops *StorageMock) GetJetDropsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetJetDrops.afterGetJetDropsCounter)
}

// GetJetDropsBeforeCounter returns a count of StorageMock.GetJetDrops invocations
func (mmGetJetDrops *StorageMock) GetJetDropsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetJetDrops.beforeGetJetDropsCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetJetDrops.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetJetDrops *mStorageMockGetJetDrops) Calls() []*StorageMockGetJetDropsParams {
	mmGetJetDrops.mutex.RLock()

	argCopy := make([]*StorageMockGetJetDropsParams, len(mmGetJetDrops.callArgs))
	copy(argCopy, mmGetJetDrops.callArgs)

	mmGetJetDrops.mutex.RUnlock()

	return argCopy
}

// MinimockGetJetDropsDone returns true if the count of the GetJetDrops invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetJetDropsDone() bool {
	for _, e := range m.GetJetDropsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetJetDropsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetJetDropsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetJetDrops != nil && mm_atomic.LoadUint64(&m.afterGetJetDropsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetJetDropsInspect logs each unmet expectation
func (m *StorageMock) MinimockGetJetDropsInspect() {
	for _, e := range m.GetJetDropsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetJetDrops with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetJetDropsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetJetDropsCounter) < 1 {
		if m.GetJetDropsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetJetDrops")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetJetDrops with params: %#v", *m.GetJetDropsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetJetDrops != nil && mm_atomic.LoadUint64(&m.afterGetJetDropsCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetJetDrops")
	}
}

type mStorageMockGetNextSavedPulse struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetNextSavedPulseExpectation
	expectations       []*StorageMockGetNextSavedPulseExpectation

	callArgs []*StorageMockGetNextSavedPulseParams
	mutex    sync.RWMutex
}

// StorageMockGetNextSavedPulseExpectation specifies expectation struct of the Storage.GetNextSavedPulse
type StorageMockGetNextSavedPulseExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetNextSavedPulseParams
	results *StorageMockGetNextSavedPulseResults
	Counter uint64
}

// StorageMockGetNextSavedPulseParams contains parameters of the Storage.GetNextSavedPulse
type StorageMockGetNextSavedPulseParams struct {
	fromPulseNumber models.Pulse
	completedOnly   bool
}

// StorageMockGetNextSavedPulseResults contains results of the Storage.GetNextSavedPulse
type StorageMockGetNextSavedPulseResults struct {
	p1  models.Pulse
	err error
}

// Expect sets up expected params for Storage.GetNextSavedPulse
func (mmGetNextSavedPulse *mStorageMockGetNextSavedPulse) Expect(fromPulseNumber models.Pulse, completedOnly bool) *mStorageMockGetNextSavedPulse {
	if mmGetNextSavedPulse.mock.funcGetNextSavedPulse != nil {
		mmGetNextSavedPulse.mock.t.Fatalf("StorageMock.GetNextSavedPulse mock is already set by Set")
	}

	if mmGetNextSavedPulse.defaultExpectation == nil {
		mmGetNextSavedPulse.defaultExpectation = &StorageMockGetNextSavedPulseExpectation{}
	}

	mmGetNextSavedPulse.defaultExpectation.params = &StorageMockGetNextSavedPulseParams{fromPulseNumber, completedOnly}
	for _, e := range mmGetNextSavedPulse.expectations {
		if minimock.Equal(e.params, mmGetNextSavedPulse.defaultExpectation.params) {
			mmGetNextSavedPulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNextSavedPulse.defaultExpectation.params)
		}
	}

	return mmGetNextSavedPulse
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetNextSavedPulse
func (mmGetNextSavedPulse *mStorageMockGetNextSavedPulse) Inspect(f func(fromPulseNumber models.Pulse, completedOnly bool)) *mStorageMockGetNextSavedPulse {
	if mmGetNextSavedPulse.mock.inspectFuncGetNextSavedPulse != nil {
		mmGetNextSavedPulse.mock.t.Fatalf("Inspect function is already set for StorageMock.GetNextSavedPulse")
	}

	mmGetNextSavedPulse.mock.inspectFuncGetNextSavedPulse = f

	return mmGetNextSavedPulse
}

// Return sets up results that will be returned by Storage.GetNextSavedPulse
func (mmGetNextSavedPulse *mStorageMockGetNextSavedPulse) Return(p1 models.Pulse, err error) *StorageMock {
	if mmGetNextSavedPulse.mock.funcGetNextSavedPulse != nil {
		mmGetNextSavedPulse.mock.t.Fatalf("StorageMock.GetNextSavedPulse mock is already set by Set")
	}

	if mmGetNextSavedPulse.defaultExpectation == nil {
		mmGetNextSavedPulse.defaultExpectation = &StorageMockGetNextSavedPulseExpectation{mock: mmGetNextSavedPulse.mock}
	}
	mmGetNextSavedPulse.defaultExpectation.results = &StorageMockGetNextSavedPulseResults{p1, err}
	return mmGetNextSavedPulse.mock
}

//Set uses given function f to mock the Storage.GetNextSavedPulse method
func (mmGetNextSavedPulse *mStorageMockGetNextSavedPulse) Set(f func(fromPulseNumber models.Pulse, completedOnly bool) (p1 models.Pulse, err error)) *StorageMock {
	if mmGetNextSavedPulse.defaultExpectation != nil {
		mmGetNextSavedPulse.mock.t.Fatalf("Default expectation is already set for the Storage.GetNextSavedPulse method")
	}

	if len(mmGetNextSavedPulse.expectations) > 0 {
		mmGetNextSavedPulse.mock.t.Fatalf("Some expectations are already set for the Storage.GetNextSavedPulse method")
	}

	mmGetNextSavedPulse.mock.funcGetNextSavedPulse = f
	return mmGetNextSavedPulse.mock
}

// When sets expectation for the Storage.GetNextSavedPulse which will trigger the result defined by the following
// Then helper
func (mmGetNextSavedPulse *mStorageMockGetNextSavedPulse) When(fromPulseNumber models.Pulse, completedOnly bool) *StorageMockGetNextSavedPulseExpectation {
	if mmGetNextSavedPulse.mock.funcGetNextSavedPulse != nil {
		mmGetNextSavedPulse.mock.t.Fatalf("StorageMock.GetNextSavedPulse mock is already set by Set")
	}

	expectation := &StorageMockGetNextSavedPulseExpectation{
		mock:   mmGetNextSavedPulse.mock,
		params: &StorageMockGetNextSavedPulseParams{fromPulseNumber, completedOnly},
	}
	mmGetNextSavedPulse.expectations = append(mmGetNextSavedPulse.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetNextSavedPulse return parameters for the expectation previously defined by the When method
func (e *StorageMockGetNextSavedPulseExpectation) Then(p1 models.Pulse, err error) *StorageMock {
	e.results = &StorageMockGetNextSavedPulseResults{p1, err}
	return e.mock
}

// GetNextSavedPulse implements interfaces.Storage
func (mmGetNextSavedPulse *StorageMock) GetNextSavedPulse(fromPulseNumber models.Pulse, completedOnly bool) (p1 models.Pulse, err error) {
	mm_atomic.AddUint64(&mmGetNextSavedPulse.beforeGetNextSavedPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNextSavedPulse.afterGetNextSavedPulseCounter, 1)

	if mmGetNextSavedPulse.inspectFuncGetNextSavedPulse != nil {
		mmGetNextSavedPulse.inspectFuncGetNextSavedPulse(fromPulseNumber, completedOnly)
	}

	mm_params := &StorageMockGetNextSavedPulseParams{fromPulseNumber, completedOnly}

	// Record call args
	mmGetNextSavedPulse.GetNextSavedPulseMock.mutex.Lock()
	mmGetNextSavedPulse.GetNextSavedPulseMock.callArgs = append(mmGetNextSavedPulse.GetNextSavedPulseMock.callArgs, mm_params)
	mmGetNextSavedPulse.GetNextSavedPulseMock.mutex.Unlock()

	for _, e := range mmGetNextSavedPulse.GetNextSavedPulseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGetNextSavedPulse.GetNextSavedPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNextSavedPulse.GetNextSavedPulseMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNextSavedPulse.GetNextSavedPulseMock.defaultExpectation.params
		mm_got := StorageMockGetNextSavedPulseParams{fromPulseNumber, completedOnly}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNextSavedPulse.t.Errorf("StorageMock.GetNextSavedPulse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNextSavedPulse.GetNextSavedPulseMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNextSavedPulse.t.Fatal("No results are set for the StorageMock.GetNextSavedPulse")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGetNextSavedPulse.funcGetNextSavedPulse != nil {
		return mmGetNextSavedPulse.funcGetNextSavedPulse(fromPulseNumber, completedOnly)
	}
	mmGetNextSavedPulse.t.Fatalf("Unexpected call to StorageMock.GetNextSavedPulse. %v %v", fromPulseNumber, completedOnly)
	return
}

// GetNextSavedPulseAfterCounter returns a count of finished StorageMock.GetNextSavedPulse invocations
func (mmGetNextSavedPulse *StorageMock) GetNextSavedPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNextSavedPulse.afterGetNextSavedPulseCounter)
}

// GetNextSavedPulseBeforeCounter returns a count of StorageMock.GetNextSavedPulse invocations
func (mmGetNextSavedPulse *StorageMock) GetNextSavedPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNextSavedPulse.beforeGetNextSavedPulseCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetNextSavedPulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNextSavedPulse *mStorageMockGetNextSavedPulse) Calls() []*StorageMockGetNextSavedPulseParams {
	mmGetNextSavedPulse.mutex.RLock()

	argCopy := make([]*StorageMockGetNextSavedPulseParams, len(mmGetNextSavedPulse.callArgs))
	copy(argCopy, mmGetNextSavedPulse.callArgs)

	mmGetNextSavedPulse.mutex.RUnlock()

	return argCopy
}

// MinimockGetNextSavedPulseDone returns true if the count of the GetNextSavedPulse invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetNextSavedPulseDone() bool {
	for _, e := range m.GetNextSavedPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNextSavedPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNextSavedPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNextSavedPulse != nil && mm_atomic.LoadUint64(&m.afterGetNextSavedPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetNextSavedPulseInspect logs each unmet expectation
func (m *StorageMock) MinimockGetNextSavedPulseInspect() {
	for _, e := range m.GetNextSavedPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetNextSavedPulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNextSavedPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNextSavedPulseCounter) < 1 {
		if m.GetNextSavedPulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetNextSavedPulse")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetNextSavedPulse with params: %#v", *m.GetNextSavedPulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNextSavedPulse != nil && mm_atomic.LoadUint64(&m.afterGetNextSavedPulseCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetNextSavedPulse")
	}
}

type mStorageMockGetPulseByPrev struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetPulseByPrevExpectation
	expectations       []*StorageMockGetPulseByPrevExpectation

	callArgs []*StorageMockGetPulseByPrevParams
	mutex    sync.RWMutex
}

// StorageMockGetPulseByPrevExpectation specifies expectation struct of the Storage.GetPulseByPrev
type StorageMockGetPulseByPrevExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetPulseByPrevParams
	results *StorageMockGetPulseByPrevResults
	Counter uint64
}

// StorageMockGetPulseByPrevParams contains parameters of the Storage.GetPulseByPrev
type StorageMockGetPulseByPrevParams struct {
	prevPulse models.Pulse
}

// StorageMockGetPulseByPrevResults contains results of the Storage.GetPulseByPrev
type StorageMockGetPulseByPrevResults struct {
	p1  models.Pulse
	err error
}

// Expect sets up expected params for Storage.GetPulseByPrev
func (mmGetPulseByPrev *mStorageMockGetPulseByPrev) Expect(prevPulse models.Pulse) *mStorageMockGetPulseByPrev {
	if mmGetPulseByPrev.mock.funcGetPulseByPrev != nil {
		mmGetPulseByPrev.mock.t.Fatalf("StorageMock.GetPulseByPrev mock is already set by Set")
	}

	if mmGetPulseByPrev.defaultExpectation == nil {
		mmGetPulseByPrev.defaultExpectation = &StorageMockGetPulseByPrevExpectation{}
	}

	mmGetPulseByPrev.defaultExpectation.params = &StorageMockGetPulseByPrevParams{prevPulse}
	for _, e := range mmGetPulseByPrev.expectations {
		if minimock.Equal(e.params, mmGetPulseByPrev.defaultExpectation.params) {
			mmGetPulseByPrev.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPulseByPrev.defaultExpectation.params)
		}
	}

	return mmGetPulseByPrev
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetPulseByPrev
func (mmGetPulseByPrev *mStorageMockGetPulseByPrev) Inspect(f func(prevPulse models.Pulse)) *mStorageMockGetPulseByPrev {
	if mmGetPulseByPrev.mock.inspectFuncGetPulseByPrev != nil {
		mmGetPulseByPrev.mock.t.Fatalf("Inspect function is already set for StorageMock.GetPulseByPrev")
	}

	mmGetPulseByPrev.mock.inspectFuncGetPulseByPrev = f

	return mmGetPulseByPrev
}

// Return sets up results that will be returned by Storage.GetPulseByPrev
func (mmGetPulseByPrev *mStorageMockGetPulseByPrev) Return(p1 models.Pulse, err error) *StorageMock {
	if mmGetPulseByPrev.mock.funcGetPulseByPrev != nil {
		mmGetPulseByPrev.mock.t.Fatalf("StorageMock.GetPulseByPrev mock is already set by Set")
	}

	if mmGetPulseByPrev.defaultExpectation == nil {
		mmGetPulseByPrev.defaultExpectation = &StorageMockGetPulseByPrevExpectation{mock: mmGetPulseByPrev.mock}
	}
	mmGetPulseByPrev.defaultExpectation.results = &StorageMockGetPulseByPrevResults{p1, err}
	return mmGetPulseByPrev.mock
}

//Set uses given function f to mock the Storage.GetPulseByPrev method
func (mmGetPulseByPrev *mStorageMockGetPulseByPrev) Set(f func(prevPulse models.Pulse) (p1 models.Pulse, err error)) *StorageMock {
	if mmGetPulseByPrev.defaultExpectation != nil {
		mmGetPulseByPrev.mock.t.Fatalf("Default expectation is already set for the Storage.GetPulseByPrev method")
	}

	if len(mmGetPulseByPrev.expectations) > 0 {
		mmGetPulseByPrev.mock.t.Fatalf("Some expectations are already set for the Storage.GetPulseByPrev method")
	}

	mmGetPulseByPrev.mock.funcGetPulseByPrev = f
	return mmGetPulseByPrev.mock
}

// When sets expectation for the Storage.GetPulseByPrev which will trigger the result defined by the following
// Then helper
func (mmGetPulseByPrev *mStorageMockGetPulseByPrev) When(prevPulse models.Pulse) *StorageMockGetPulseByPrevExpectation {
	if mmGetPulseByPrev.mock.funcGetPulseByPrev != nil {
		mmGetPulseByPrev.mock.t.Fatalf("StorageMock.GetPulseByPrev mock is already set by Set")
	}

	expectation := &StorageMockGetPulseByPrevExpectation{
		mock:   mmGetPulseByPrev.mock,
		params: &StorageMockGetPulseByPrevParams{prevPulse},
	}
	mmGetPulseByPrev.expectations = append(mmGetPulseByPrev.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetPulseByPrev return parameters for the expectation previously defined by the When method
func (e *StorageMockGetPulseByPrevExpectation) Then(p1 models.Pulse, err error) *StorageMock {
	e.results = &StorageMockGetPulseByPrevResults{p1, err}
	return e.mock
}

// GetPulseByPrev implements interfaces.Storage
func (mmGetPulseByPrev *StorageMock) GetPulseByPrev(prevPulse models.Pulse) (p1 models.Pulse, err error) {
	mm_atomic.AddUint64(&mmGetPulseByPrev.beforeGetPulseByPrevCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPulseByPrev.afterGetPulseByPrevCounter, 1)

	if mmGetPulseByPrev.inspectFuncGetPulseByPrev != nil {
		mmGetPulseByPrev.inspectFuncGetPulseByPrev(prevPulse)
	}

	mm_params := &StorageMockGetPulseByPrevParams{prevPulse}

	// Record call args
	mmGetPulseByPrev.GetPulseByPrevMock.mutex.Lock()
	mmGetPulseByPrev.GetPulseByPrevMock.callArgs = append(mmGetPulseByPrev.GetPulseByPrevMock.callArgs, mm_params)
	mmGetPulseByPrev.GetPulseByPrevMock.mutex.Unlock()

	for _, e := range mmGetPulseByPrev.GetPulseByPrevMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGetPulseByPrev.GetPulseByPrevMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPulseByPrev.GetPulseByPrevMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPulseByPrev.GetPulseByPrevMock.defaultExpectation.params
		mm_got := StorageMockGetPulseByPrevParams{prevPulse}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPulseByPrev.t.Errorf("StorageMock.GetPulseByPrev got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPulseByPrev.GetPulseByPrevMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPulseByPrev.t.Fatal("No results are set for the StorageMock.GetPulseByPrev")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGetPulseByPrev.funcGetPulseByPrev != nil {
		return mmGetPulseByPrev.funcGetPulseByPrev(prevPulse)
	}
	mmGetPulseByPrev.t.Fatalf("Unexpected call to StorageMock.GetPulseByPrev. %v", prevPulse)
	return
}

// GetPulseByPrevAfterCounter returns a count of finished StorageMock.GetPulseByPrev invocations
func (mmGetPulseByPrev *StorageMock) GetPulseByPrevAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPulseByPrev.afterGetPulseByPrevCounter)
}

// GetPulseByPrevBeforeCounter returns a count of StorageMock.GetPulseByPrev invocations
func (mmGetPulseByPrev *StorageMock) GetPulseByPrevBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPulseByPrev.beforeGetPulseByPrevCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetPulseByPrev.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPulseByPrev *mStorageMockGetPulseByPrev) Calls() []*StorageMockGetPulseByPrevParams {
	mmGetPulseByPrev.mutex.RLock()

	argCopy := make([]*StorageMockGetPulseByPrevParams, len(mmGetPulseByPrev.callArgs))
	copy(argCopy, mmGetPulseByPrev.callArgs)

	mmGetPulseByPrev.mutex.RUnlock()

	return argCopy
}

// MinimockGetPulseByPrevDone returns true if the count of the GetPulseByPrev invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetPulseByPrevDone() bool {
	for _, e := range m.GetPulseByPrevMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPulseByPrevMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPulseByPrevCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPulseByPrev != nil && mm_atomic.LoadUint64(&m.afterGetPulseByPrevCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPulseByPrevInspect logs each unmet expectation
func (m *StorageMock) MinimockGetPulseByPrevInspect() {
	for _, e := range m.GetPulseByPrevMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetPulseByPrev with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPulseByPrevMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPulseByPrevCounter) < 1 {
		if m.GetPulseByPrevMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetPulseByPrev")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetPulseByPrev with params: %#v", *m.GetPulseByPrevMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPulseByPrev != nil && mm_atomic.LoadUint64(&m.afterGetPulseByPrevCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetPulseByPrev")
	}
}

type mStorageMockGetSequentialPulse struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetSequentialPulseExpectation
	expectations       []*StorageMockGetSequentialPulseExpectation
}

// StorageMockGetSequentialPulseExpectation specifies expectation struct of the Storage.GetSequentialPulse
type StorageMockGetSequentialPulseExpectation struct {
	mock *StorageMock

	results *StorageMockGetSequentialPulseResults
	Counter uint64
}

// StorageMockGetSequentialPulseResults contains results of the Storage.GetSequentialPulse
type StorageMockGetSequentialPulseResults struct {
	p1  models.Pulse
	err error
}

// Expect sets up expected params for Storage.GetSequentialPulse
func (mmGetSequentialPulse *mStorageMockGetSequentialPulse) Expect() *mStorageMockGetSequentialPulse {
	if mmGetSequentialPulse.mock.funcGetSequentialPulse != nil {
		mmGetSequentialPulse.mock.t.Fatalf("StorageMock.GetSequentialPulse mock is already set by Set")
	}

	if mmGetSequentialPulse.defaultExpectation == nil {
		mmGetSequentialPulse.defaultExpectation = &StorageMockGetSequentialPulseExpectation{}
	}

	return mmGetSequentialPulse
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetSequentialPulse
func (mmGetSequentialPulse *mStorageMockGetSequentialPulse) Inspect(f func()) *mStorageMockGetSequentialPulse {
	if mmGetSequentialPulse.mock.inspectFuncGetSequentialPulse != nil {
		mmGetSequentialPulse.mock.t.Fatalf("Inspect function is already set for StorageMock.GetSequentialPulse")
	}

	mmGetSequentialPulse.mock.inspectFuncGetSequentialPulse = f

	return mmGetSequentialPulse
}

// Return sets up results that will be returned by Storage.GetSequentialPulse
func (mmGetSequentialPulse *mStorageMockGetSequentialPulse) Return(p1 models.Pulse, err error) *StorageMock {
	if mmGetSequentialPulse.mock.funcGetSequentialPulse != nil {
		mmGetSequentialPulse.mock.t.Fatalf("StorageMock.GetSequentialPulse mock is already set by Set")
	}

	if mmGetSequentialPulse.defaultExpectation == nil {
		mmGetSequentialPulse.defaultExpectation = &StorageMockGetSequentialPulseExpectation{mock: mmGetSequentialPulse.mock}
	}
	mmGetSequentialPulse.defaultExpectation.results = &StorageMockGetSequentialPulseResults{p1, err}
	return mmGetSequentialPulse.mock
}

//Set uses given function f to mock the Storage.GetSequentialPulse method
func (mmGetSequentialPulse *mStorageMockGetSequentialPulse) Set(f func() (p1 models.Pulse, err error)) *StorageMock {
	if mmGetSequentialPulse.defaultExpectation != nil {
		mmGetSequentialPulse.mock.t.Fatalf("Default expectation is already set for the Storage.GetSequentialPulse method")
	}

	if len(mmGetSequentialPulse.expectations) > 0 {
		mmGetSequentialPulse.mock.t.Fatalf("Some expectations are already set for the Storage.GetSequentialPulse method")
	}

	mmGetSequentialPulse.mock.funcGetSequentialPulse = f
	return mmGetSequentialPulse.mock
}

// GetSequentialPulse implements interfaces.Storage
func (mmGetSequentialPulse *StorageMock) GetSequentialPulse() (p1 models.Pulse, err error) {
	mm_atomic.AddUint64(&mmGetSequentialPulse.beforeGetSequentialPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSequentialPulse.afterGetSequentialPulseCounter, 1)

	if mmGetSequentialPulse.inspectFuncGetSequentialPulse != nil {
		mmGetSequentialPulse.inspectFuncGetSequentialPulse()
	}

	if mmGetSequentialPulse.GetSequentialPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSequentialPulse.GetSequentialPulseMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSequentialPulse.GetSequentialPulseMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSequentialPulse.t.Fatal("No results are set for the StorageMock.GetSequentialPulse")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGetSequentialPulse.funcGetSequentialPulse != nil {
		return mmGetSequentialPulse.funcGetSequentialPulse()
	}
	mmGetSequentialPulse.t.Fatalf("Unexpected call to StorageMock.GetSequentialPulse.")
	return
}

// GetSequentialPulseAfterCounter returns a count of finished StorageMock.GetSequentialPulse invocations
func (mmGetSequentialPulse *StorageMock) GetSequentialPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSequentialPulse.afterGetSequentialPulseCounter)
}

// GetSequentialPulseBeforeCounter returns a count of StorageMock.GetSequentialPulse invocations
func (mmGetSequentialPulse *StorageMock) GetSequentialPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSequentialPulse.beforeGetSequentialPulseCounter)
}

// MinimockGetSequentialPulseDone returns true if the count of the GetSequentialPulse invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetSequentialPulseDone() bool {
	for _, e := range m.GetSequentialPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSequentialPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSequentialPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSequentialPulse != nil && mm_atomic.LoadUint64(&m.afterGetSequentialPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSequentialPulseInspect logs each unmet expectation
func (m *StorageMock) MinimockGetSequentialPulseInspect() {
	for _, e := range m.GetSequentialPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.GetSequentialPulse")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSequentialPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSequentialPulseCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetSequentialPulse")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSequentialPulse != nil && mm_atomic.LoadUint64(&m.afterGetSequentialPulseCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetSequentialPulse")
	}
}

type mStorageMockSaveJetDropData struct {
	mock               *StorageMock
	defaultExpectation *StorageMockSaveJetDropDataExpectation
	expectations       []*StorageMockSaveJetDropDataExpectation

	callArgs []*StorageMockSaveJetDropDataParams
	mutex    sync.RWMutex
}

// StorageMockSaveJetDropDataExpectation specifies expectation struct of the Storage.SaveJetDropData
type StorageMockSaveJetDropDataExpectation struct {
	mock    *StorageMock
	params  *StorageMockSaveJetDropDataParams
	results *StorageMockSaveJetDropDataResults
	Counter uint64
}

// StorageMockSaveJetDropDataParams contains parameters of the Storage.SaveJetDropData
type StorageMockSaveJetDropDataParams struct {
	jetDrop     models.JetDrop
	records     []models.Record
	pulseNumber int64
}

// StorageMockSaveJetDropDataResults contains results of the Storage.SaveJetDropData
type StorageMockSaveJetDropDataResults struct {
	err error
}

// Expect sets up expected params for Storage.SaveJetDropData
func (mmSaveJetDropData *mStorageMockSaveJetDropData) Expect(jetDrop models.JetDrop, records []models.Record, pulseNumber int64) *mStorageMockSaveJetDropData {
	if mmSaveJetDropData.mock.funcSaveJetDropData != nil {
		mmSaveJetDropData.mock.t.Fatalf("StorageMock.SaveJetDropData mock is already set by Set")
	}

	if mmSaveJetDropData.defaultExpectation == nil {
		mmSaveJetDropData.defaultExpectation = &StorageMockSaveJetDropDataExpectation{}
	}

	mmSaveJetDropData.defaultExpectation.params = &StorageMockSaveJetDropDataParams{jetDrop, records, pulseNumber}
	for _, e := range mmSaveJetDropData.expectations {
		if minimock.Equal(e.params, mmSaveJetDropData.defaultExpectation.params) {
			mmSaveJetDropData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveJetDropData.defaultExpectation.params)
		}
	}

	return mmSaveJetDropData
}

// Inspect accepts an inspector function that has same arguments as the Storage.SaveJetDropData
func (mmSaveJetDropData *mStorageMockSaveJetDropData) Inspect(f func(jetDrop models.JetDrop, records []models.Record, pulseNumber int64)) *mStorageMockSaveJetDropData {
	if mmSaveJetDropData.mock.inspectFuncSaveJetDropData != nil {
		mmSaveJetDropData.mock.t.Fatalf("Inspect function is already set for StorageMock.SaveJetDropData")
	}

	mmSaveJetDropData.mock.inspectFuncSaveJetDropData = f

	return mmSaveJetDropData
}

// Return sets up results that will be returned by Storage.SaveJetDropData
func (mmSaveJetDropData *mStorageMockSaveJetDropData) Return(err error) *StorageMock {
	if mmSaveJetDropData.mock.funcSaveJetDropData != nil {
		mmSaveJetDropData.mock.t.Fatalf("StorageMock.SaveJetDropData mock is already set by Set")
	}

	if mmSaveJetDropData.defaultExpectation == nil {
		mmSaveJetDropData.defaultExpectation = &StorageMockSaveJetDropDataExpectation{mock: mmSaveJetDropData.mock}
	}
	mmSaveJetDropData.defaultExpectation.results = &StorageMockSaveJetDropDataResults{err}
	return mmSaveJetDropData.mock
}

//Set uses given function f to mock the Storage.SaveJetDropData method
func (mmSaveJetDropData *mStorageMockSaveJetDropData) Set(f func(jetDrop models.JetDrop, records []models.Record, pulseNumber int64) (err error)) *StorageMock {
	if mmSaveJetDropData.defaultExpectation != nil {
		mmSaveJetDropData.mock.t.Fatalf("Default expectation is already set for the Storage.SaveJetDropData method")
	}

	if len(mmSaveJetDropData.expectations) > 0 {
		mmSaveJetDropData.mock.t.Fatalf("Some expectations are already set for the Storage.SaveJetDropData method")
	}

	mmSaveJetDropData.mock.funcSaveJetDropData = f
	return mmSaveJetDropData.mock
}

// When sets expectation for the Storage.SaveJetDropData which will trigger the result defined by the following
// Then helper
func (mmSaveJetDropData *mStorageMockSaveJetDropData) When(jetDrop models.JetDrop, records []models.Record, pulseNumber int64) *StorageMockSaveJetDropDataExpectation {
	if mmSaveJetDropData.mock.funcSaveJetDropData != nil {
		mmSaveJetDropData.mock.t.Fatalf("StorageMock.SaveJetDropData mock is already set by Set")
	}

	expectation := &StorageMockSaveJetDropDataExpectation{
		mock:   mmSaveJetDropData.mock,
		params: &StorageMockSaveJetDropDataParams{jetDrop, records, pulseNumber},
	}
	mmSaveJetDropData.expectations = append(mmSaveJetDropData.expectations, expectation)
	return expectation
}

// Then sets up Storage.SaveJetDropData return parameters for the expectation previously defined by the When method
func (e *StorageMockSaveJetDropDataExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockSaveJetDropDataResults{err}
	return e.mock
}

// SaveJetDropData implements interfaces.Storage
func (mmSaveJetDropData *StorageMock) SaveJetDropData(jetDrop models.JetDrop, records []models.Record, pulseNumber int64) (err error) {
	mm_atomic.AddUint64(&mmSaveJetDropData.beforeSaveJetDropDataCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveJetDropData.afterSaveJetDropDataCounter, 1)

	if mmSaveJetDropData.inspectFuncSaveJetDropData != nil {
		mmSaveJetDropData.inspectFuncSaveJetDropData(jetDrop, records, pulseNumber)
	}

	mm_params := &StorageMockSaveJetDropDataParams{jetDrop, records, pulseNumber}

	// Record call args
	mmSaveJetDropData.SaveJetDropDataMock.mutex.Lock()
	mmSaveJetDropData.SaveJetDropDataMock.callArgs = append(mmSaveJetDropData.SaveJetDropDataMock.callArgs, mm_params)
	mmSaveJetDropData.SaveJetDropDataMock.mutex.Unlock()

	for _, e := range mmSaveJetDropData.SaveJetDropDataMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveJetDropData.SaveJetDropDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveJetDropData.SaveJetDropDataMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveJetDropData.SaveJetDropDataMock.defaultExpectation.params
		mm_got := StorageMockSaveJetDropDataParams{jetDrop, records, pulseNumber}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveJetDropData.t.Errorf("StorageMock.SaveJetDropData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveJetDropData.SaveJetDropDataMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveJetDropData.t.Fatal("No results are set for the StorageMock.SaveJetDropData")
		}
		return (*mm_results).err
	}
	if mmSaveJetDropData.funcSaveJetDropData != nil {
		return mmSaveJetDropData.funcSaveJetDropData(jetDrop, records, pulseNumber)
	}
	mmSaveJetDropData.t.Fatalf("Unexpected call to StorageMock.SaveJetDropData. %v %v %v", jetDrop, records, pulseNumber)
	return
}

// SaveJetDropDataAfterCounter returns a count of finished StorageMock.SaveJetDropData invocations
func (mmSaveJetDropData *StorageMock) SaveJetDropDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveJetDropData.afterSaveJetDropDataCounter)
}

// SaveJetDropDataBeforeCounter returns a count of StorageMock.SaveJetDropData invocations
func (mmSaveJetDropData *StorageMock) SaveJetDropDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveJetDropData.beforeSaveJetDropDataCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SaveJetDropData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveJetDropData *mStorageMockSaveJetDropData) Calls() []*StorageMockSaveJetDropDataParams {
	mmSaveJetDropData.mutex.RLock()

	argCopy := make([]*StorageMockSaveJetDropDataParams, len(mmSaveJetDropData.callArgs))
	copy(argCopy, mmSaveJetDropData.callArgs)

	mmSaveJetDropData.mutex.RUnlock()

	return argCopy
}

// MinimockSaveJetDropDataDone returns true if the count of the SaveJetDropData invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSaveJetDropDataDone() bool {
	for _, e := range m.SaveJetDropDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveJetDropDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveJetDropDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveJetDropData != nil && mm_atomic.LoadUint64(&m.afterSaveJetDropDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveJetDropDataInspect logs each unmet expectation
func (m *StorageMock) MinimockSaveJetDropDataInspect() {
	for _, e := range m.SaveJetDropDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SaveJetDropData with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveJetDropDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveJetDropDataCounter) < 1 {
		if m.SaveJetDropDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.SaveJetDropData")
		} else {
			m.t.Errorf("Expected call to StorageMock.SaveJetDropData with params: %#v", *m.SaveJetDropDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveJetDropData != nil && mm_atomic.LoadUint64(&m.afterSaveJetDropDataCounter) < 1 {
		m.t.Error("Expected call to StorageMock.SaveJetDropData")
	}
}

type mStorageMockSavePulse struct {
	mock               *StorageMock
	defaultExpectation *StorageMockSavePulseExpectation
	expectations       []*StorageMockSavePulseExpectation

	callArgs []*StorageMockSavePulseParams
	mutex    sync.RWMutex
}

// StorageMockSavePulseExpectation specifies expectation struct of the Storage.SavePulse
type StorageMockSavePulseExpectation struct {
	mock    *StorageMock
	params  *StorageMockSavePulseParams
	results *StorageMockSavePulseResults
	Counter uint64
}

// StorageMockSavePulseParams contains parameters of the Storage.SavePulse
type StorageMockSavePulseParams struct {
	pulse models.Pulse
}

// StorageMockSavePulseResults contains results of the Storage.SavePulse
type StorageMockSavePulseResults struct {
	err error
}

// Expect sets up expected params for Storage.SavePulse
func (mmSavePulse *mStorageMockSavePulse) Expect(pulse models.Pulse) *mStorageMockSavePulse {
	if mmSavePulse.mock.funcSavePulse != nil {
		mmSavePulse.mock.t.Fatalf("StorageMock.SavePulse mock is already set by Set")
	}

	if mmSavePulse.defaultExpectation == nil {
		mmSavePulse.defaultExpectation = &StorageMockSavePulseExpectation{}
	}

	mmSavePulse.defaultExpectation.params = &StorageMockSavePulseParams{pulse}
	for _, e := range mmSavePulse.expectations {
		if minimock.Equal(e.params, mmSavePulse.defaultExpectation.params) {
			mmSavePulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSavePulse.defaultExpectation.params)
		}
	}

	return mmSavePulse
}

// Inspect accepts an inspector function that has same arguments as the Storage.SavePulse
func (mmSavePulse *mStorageMockSavePulse) Inspect(f func(pulse models.Pulse)) *mStorageMockSavePulse {
	if mmSavePulse.mock.inspectFuncSavePulse != nil {
		mmSavePulse.mock.t.Fatalf("Inspect function is already set for StorageMock.SavePulse")
	}

	mmSavePulse.mock.inspectFuncSavePulse = f

	return mmSavePulse
}

// Return sets up results that will be returned by Storage.SavePulse
func (mmSavePulse *mStorageMockSavePulse) Return(err error) *StorageMock {
	if mmSavePulse.mock.funcSavePulse != nil {
		mmSavePulse.mock.t.Fatalf("StorageMock.SavePulse mock is already set by Set")
	}

	if mmSavePulse.defaultExpectation == nil {
		mmSavePulse.defaultExpectation = &StorageMockSavePulseExpectation{mock: mmSavePulse.mock}
	}
	mmSavePulse.defaultExpectation.results = &StorageMockSavePulseResults{err}
	return mmSavePulse.mock
}

//Set uses given function f to mock the Storage.SavePulse method
func (mmSavePulse *mStorageMockSavePulse) Set(f func(pulse models.Pulse) (err error)) *StorageMock {
	if mmSavePulse.defaultExpectation != nil {
		mmSavePulse.mock.t.Fatalf("Default expectation is already set for the Storage.SavePulse method")
	}

	if len(mmSavePulse.expectations) > 0 {
		mmSavePulse.mock.t.Fatalf("Some expectations are already set for the Storage.SavePulse method")
	}

	mmSavePulse.mock.funcSavePulse = f
	return mmSavePulse.mock
}

// When sets expectation for the Storage.SavePulse which will trigger the result defined by the following
// Then helper
func (mmSavePulse *mStorageMockSavePulse) When(pulse models.Pulse) *StorageMockSavePulseExpectation {
	if mmSavePulse.mock.funcSavePulse != nil {
		mmSavePulse.mock.t.Fatalf("StorageMock.SavePulse mock is already set by Set")
	}

	expectation := &StorageMockSavePulseExpectation{
		mock:   mmSavePulse.mock,
		params: &StorageMockSavePulseParams{pulse},
	}
	mmSavePulse.expectations = append(mmSavePulse.expectations, expectation)
	return expectation
}

// Then sets up Storage.SavePulse return parameters for the expectation previously defined by the When method
func (e *StorageMockSavePulseExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockSavePulseResults{err}
	return e.mock
}

// SavePulse implements interfaces.Storage
func (mmSavePulse *StorageMock) SavePulse(pulse models.Pulse) (err error) {
	mm_atomic.AddUint64(&mmSavePulse.beforeSavePulseCounter, 1)
	defer mm_atomic.AddUint64(&mmSavePulse.afterSavePulseCounter, 1)

	if mmSavePulse.inspectFuncSavePulse != nil {
		mmSavePulse.inspectFuncSavePulse(pulse)
	}

	mm_params := &StorageMockSavePulseParams{pulse}

	// Record call args
	mmSavePulse.SavePulseMock.mutex.Lock()
	mmSavePulse.SavePulseMock.callArgs = append(mmSavePulse.SavePulseMock.callArgs, mm_params)
	mmSavePulse.SavePulseMock.mutex.Unlock()

	for _, e := range mmSavePulse.SavePulseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSavePulse.SavePulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSavePulse.SavePulseMock.defaultExpectation.Counter, 1)
		mm_want := mmSavePulse.SavePulseMock.defaultExpectation.params
		mm_got := StorageMockSavePulseParams{pulse}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSavePulse.t.Errorf("StorageMock.SavePulse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSavePulse.SavePulseMock.defaultExpectation.results
		if mm_results == nil {
			mmSavePulse.t.Fatal("No results are set for the StorageMock.SavePulse")
		}
		return (*mm_results).err
	}
	if mmSavePulse.funcSavePulse != nil {
		return mmSavePulse.funcSavePulse(pulse)
	}
	mmSavePulse.t.Fatalf("Unexpected call to StorageMock.SavePulse. %v", pulse)
	return
}

// SavePulseAfterCounter returns a count of finished StorageMock.SavePulse invocations
func (mmSavePulse *StorageMock) SavePulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSavePulse.afterSavePulseCounter)
}

// SavePulseBeforeCounter returns a count of StorageMock.SavePulse invocations
func (mmSavePulse *StorageMock) SavePulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSavePulse.beforeSavePulseCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SavePulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSavePulse *mStorageMockSavePulse) Calls() []*StorageMockSavePulseParams {
	mmSavePulse.mutex.RLock()

	argCopy := make([]*StorageMockSavePulseParams, len(mmSavePulse.callArgs))
	copy(argCopy, mmSavePulse.callArgs)

	mmSavePulse.mutex.RUnlock()

	return argCopy
}

// MinimockSavePulseDone returns true if the count of the SavePulse invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSavePulseDone() bool {
	for _, e := range m.SavePulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SavePulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSavePulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSavePulse != nil && mm_atomic.LoadUint64(&m.afterSavePulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockSavePulseInspect logs each unmet expectation
func (m *StorageMock) MinimockSavePulseInspect() {
	for _, e := range m.SavePulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SavePulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SavePulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSavePulseCounter) < 1 {
		if m.SavePulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.SavePulse")
		} else {
			m.t.Errorf("Expected call to StorageMock.SavePulse with params: %#v", *m.SavePulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSavePulse != nil && mm_atomic.LoadUint64(&m.afterSavePulseCounter) < 1 {
		m.t.Error("Expected call to StorageMock.SavePulse")
	}
}

type mStorageMockSequencePulse struct {
	mock               *StorageMock
	defaultExpectation *StorageMockSequencePulseExpectation
	expectations       []*StorageMockSequencePulseExpectation

	callArgs []*StorageMockSequencePulseParams
	mutex    sync.RWMutex
}

// StorageMockSequencePulseExpectation specifies expectation struct of the Storage.SequencePulse
type StorageMockSequencePulseExpectation struct {
	mock    *StorageMock
	params  *StorageMockSequencePulseParams
	results *StorageMockSequencePulseResults
	Counter uint64
}

// StorageMockSequencePulseParams contains parameters of the Storage.SequencePulse
type StorageMockSequencePulseParams struct {
	pulseNumber int64
}

// StorageMockSequencePulseResults contains results of the Storage.SequencePulse
type StorageMockSequencePulseResults struct {
	err error
}

// Expect sets up expected params for Storage.SequencePulse
func (mmSequencePulse *mStorageMockSequencePulse) Expect(pulseNumber int64) *mStorageMockSequencePulse {
	if mmSequencePulse.mock.funcSequencePulse != nil {
		mmSequencePulse.mock.t.Fatalf("StorageMock.SequencePulse mock is already set by Set")
	}

	if mmSequencePulse.defaultExpectation == nil {
		mmSequencePulse.defaultExpectation = &StorageMockSequencePulseExpectation{}
	}

	mmSequencePulse.defaultExpectation.params = &StorageMockSequencePulseParams{pulseNumber}
	for _, e := range mmSequencePulse.expectations {
		if minimock.Equal(e.params, mmSequencePulse.defaultExpectation.params) {
			mmSequencePulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSequencePulse.defaultExpectation.params)
		}
	}

	return mmSequencePulse
}

// Inspect accepts an inspector function that has same arguments as the Storage.SequencePulse
func (mmSequencePulse *mStorageMockSequencePulse) Inspect(f func(pulseNumber int64)) *mStorageMockSequencePulse {
	if mmSequencePulse.mock.inspectFuncSequencePulse != nil {
		mmSequencePulse.mock.t.Fatalf("Inspect function is already set for StorageMock.SequencePulse")
	}

	mmSequencePulse.mock.inspectFuncSequencePulse = f

	return mmSequencePulse
}

// Return sets up results that will be returned by Storage.SequencePulse
func (mmSequencePulse *mStorageMockSequencePulse) Return(err error) *StorageMock {
	if mmSequencePulse.mock.funcSequencePulse != nil {
		mmSequencePulse.mock.t.Fatalf("StorageMock.SequencePulse mock is already set by Set")
	}

	if mmSequencePulse.defaultExpectation == nil {
		mmSequencePulse.defaultExpectation = &StorageMockSequencePulseExpectation{mock: mmSequencePulse.mock}
	}
	mmSequencePulse.defaultExpectation.results = &StorageMockSequencePulseResults{err}
	return mmSequencePulse.mock
}

//Set uses given function f to mock the Storage.SequencePulse method
func (mmSequencePulse *mStorageMockSequencePulse) Set(f func(pulseNumber int64) (err error)) *StorageMock {
	if mmSequencePulse.defaultExpectation != nil {
		mmSequencePulse.mock.t.Fatalf("Default expectation is already set for the Storage.SequencePulse method")
	}

	if len(mmSequencePulse.expectations) > 0 {
		mmSequencePulse.mock.t.Fatalf("Some expectations are already set for the Storage.SequencePulse method")
	}

	mmSequencePulse.mock.funcSequencePulse = f
	return mmSequencePulse.mock
}

// When sets expectation for the Storage.SequencePulse which will trigger the result defined by the following
// Then helper
func (mmSequencePulse *mStorageMockSequencePulse) When(pulseNumber int64) *StorageMockSequencePulseExpectation {
	if mmSequencePulse.mock.funcSequencePulse != nil {
		mmSequencePulse.mock.t.Fatalf("StorageMock.SequencePulse mock is already set by Set")
	}

	expectation := &StorageMockSequencePulseExpectation{
		mock:   mmSequencePulse.mock,
		params: &StorageMockSequencePulseParams{pulseNumber},
	}
	mmSequencePulse.expectations = append(mmSequencePulse.expectations, expectation)
	return expectation
}

// Then sets up Storage.SequencePulse return parameters for the expectation previously defined by the When method
func (e *StorageMockSequencePulseExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockSequencePulseResults{err}
	return e.mock
}

// SequencePulse implements interfaces.Storage
func (mmSequencePulse *StorageMock) SequencePulse(pulseNumber int64) (err error) {
	mm_atomic.AddUint64(&mmSequencePulse.beforeSequencePulseCounter, 1)
	defer mm_atomic.AddUint64(&mmSequencePulse.afterSequencePulseCounter, 1)

	if mmSequencePulse.inspectFuncSequencePulse != nil {
		mmSequencePulse.inspectFuncSequencePulse(pulseNumber)
	}

	mm_params := &StorageMockSequencePulseParams{pulseNumber}

	// Record call args
	mmSequencePulse.SequencePulseMock.mutex.Lock()
	mmSequencePulse.SequencePulseMock.callArgs = append(mmSequencePulse.SequencePulseMock.callArgs, mm_params)
	mmSequencePulse.SequencePulseMock.mutex.Unlock()

	for _, e := range mmSequencePulse.SequencePulseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSequencePulse.SequencePulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSequencePulse.SequencePulseMock.defaultExpectation.Counter, 1)
		mm_want := mmSequencePulse.SequencePulseMock.defaultExpectation.params
		mm_got := StorageMockSequencePulseParams{pulseNumber}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSequencePulse.t.Errorf("StorageMock.SequencePulse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSequencePulse.SequencePulseMock.defaultExpectation.results
		if mm_results == nil {
			mmSequencePulse.t.Fatal("No results are set for the StorageMock.SequencePulse")
		}
		return (*mm_results).err
	}
	if mmSequencePulse.funcSequencePulse != nil {
		return mmSequencePulse.funcSequencePulse(pulseNumber)
	}
	mmSequencePulse.t.Fatalf("Unexpected call to StorageMock.SequencePulse. %v", pulseNumber)
	return
}

// SequencePulseAfterCounter returns a count of finished StorageMock.SequencePulse invocations
func (mmSequencePulse *StorageMock) SequencePulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSequencePulse.afterSequencePulseCounter)
}

// SequencePulseBeforeCounter returns a count of StorageMock.SequencePulse invocations
func (mmSequencePulse *StorageMock) SequencePulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSequencePulse.beforeSequencePulseCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SequencePulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSequencePulse *mStorageMockSequencePulse) Calls() []*StorageMockSequencePulseParams {
	mmSequencePulse.mutex.RLock()

	argCopy := make([]*StorageMockSequencePulseParams, len(mmSequencePulse.callArgs))
	copy(argCopy, mmSequencePulse.callArgs)

	mmSequencePulse.mutex.RUnlock()

	return argCopy
}

// MinimockSequencePulseDone returns true if the count of the SequencePulse invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSequencePulseDone() bool {
	for _, e := range m.SequencePulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SequencePulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSequencePulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSequencePulse != nil && mm_atomic.LoadUint64(&m.afterSequencePulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockSequencePulseInspect logs each unmet expectation
func (m *StorageMock) MinimockSequencePulseInspect() {
	for _, e := range m.SequencePulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SequencePulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SequencePulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSequencePulseCounter) < 1 {
		if m.SequencePulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.SequencePulse")
		} else {
			m.t.Errorf("Expected call to StorageMock.SequencePulse with params: %#v", *m.SequencePulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSequencePulse != nil && mm_atomic.LoadUint64(&m.afterSequencePulseCounter) < 1 {
		m.t.Error("Expected call to StorageMock.SequencePulse")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCompletePulseInspect()

		m.MinimockGetIncompletePulsesInspect()

		m.MinimockGetJetDropsInspect()

		m.MinimockGetNextSavedPulseInspect()

		m.MinimockGetPulseByPrevInspect()

		m.MinimockGetSequentialPulseInspect()

		m.MinimockSaveJetDropDataInspect()

		m.MinimockSavePulseInspect()

		m.MinimockSequencePulseInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCompletePulseDone() &&
		m.MinimockGetIncompletePulsesDone() &&
		m.MinimockGetJetDropsDone() &&
		m.MinimockGetNextSavedPulseDone() &&
		m.MinimockGetPulseByPrevDone() &&
		m.MinimockGetSequentialPulseDone() &&
		m.MinimockSaveJetDropDataDone() &&
		m.MinimockSavePulseDone() &&
		m.MinimockSequencePulseDone()
}
