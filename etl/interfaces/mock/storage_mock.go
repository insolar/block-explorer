package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/block-explorer/etl/models"
)

// StorageMock implements interfaces.Storage
type StorageMock struct {
	t minimock.Tester

	funcCompletePulse          func(pulseNumber int) (err error)
	inspectFuncCompletePulse   func(pulseNumber int)
	afterCompletePulseCounter  uint64
	beforeCompletePulseCounter uint64
	CompletePulseMock          mStorageMockCompletePulse

	funcGetAmounts          func(pulseNumber int) (jdAmount int64, rAmount int64, err error)
	inspectFuncGetAmounts   func(pulseNumber int)
	afterGetAmountsCounter  uint64
	beforeGetAmountsCounter uint64
	GetAmountsMock          mStorageMockGetAmounts

	funcGetIncompletePulses          func() (pa1 []models.Pulse, err error)
	inspectFuncGetIncompletePulses   func()
	afterGetIncompletePulsesCounter  uint64
	beforeGetIncompletePulsesCounter uint64
	GetIncompletePulsesMock          mStorageMockGetIncompletePulses

	funcGetJetDropByID          func(id models.JetDropID) (j1 models.JetDrop, err error)
	inspectFuncGetJetDropByID   func(id models.JetDropID)
	afterGetJetDropByIDCounter  uint64
	beforeGetJetDropByIDCounter uint64
	GetJetDropByIDMock          mStorageMockGetJetDropByID

	funcGetJetDrops          func(pulse models.Pulse) (ja1 []models.JetDrop, err error)
	inspectFuncGetJetDrops   func(pulse models.Pulse)
	afterGetJetDropsCounter  uint64
	beforeGetJetDropsCounter uint64
	GetJetDropsMock          mStorageMockGetJetDrops

	funcGetJetDropsWithParams          func(pulse models.Pulse, fromJetDropID *models.JetDropID, limit int, offset int) (ja1 []models.JetDrop, i1 int, err error)
	inspectFuncGetJetDropsWithParams   func(pulse models.Pulse, fromJetDropID *models.JetDropID, limit int, offset int)
	afterGetJetDropsWithParamsCounter  uint64
	beforeGetJetDropsWithParamsCounter uint64
	GetJetDropsWithParamsMock          mStorageMockGetJetDropsWithParams

	funcGetLifeline          func(objRef []byte, fromIndex *string, pulseNumberLt *int, pulseNumberGt *int, timestampLte *int, timestampGte *int, limit int, offset int, sort string) (ra1 []models.Record, i1 int, err error)
	inspectFuncGetLifeline   func(objRef []byte, fromIndex *string, pulseNumberLt *int, pulseNumberGt *int, timestampLte *int, timestampGte *int, limit int, offset int, sort string)
	afterGetLifelineCounter  uint64
	beforeGetLifelineCounter uint64
	GetLifelineMock          mStorageMockGetLifeline

	funcGetPulse          func(pulseNumber int) (p1 models.Pulse, i1 int64, i2 int64, err error)
	inspectFuncGetPulse   func(pulseNumber int)
	afterGetPulseCounter  uint64
	beforeGetPulseCounter uint64
	GetPulseMock          mStorageMockGetPulse

	funcGetPulses          func(fromPulse *int64, timestampLte *int, timestampGte *int, limit int, offset int) (pa1 []models.Pulse, i1 int, err error)
	inspectFuncGetPulses   func(fromPulse *int64, timestampLte *int, timestampGte *int, limit int, offset int)
	afterGetPulsesCounter  uint64
	beforeGetPulsesCounter uint64
	GetPulsesMock          mStorageMockGetPulses

	funcGetRecord          func(ref models.Reference) (r1 models.Record, err error)
	inspectFuncGetRecord   func(ref models.Reference)
	afterGetRecordCounter  uint64
	beforeGetRecordCounter uint64
	GetRecordMock          mStorageMockGetRecord

	funcGetRecordsByJetDrop          func(jetDropID models.JetDropID, fromIndex *string, recordType *string, limit int, offset int) (ra1 []models.Record, i1 int, err error)
	inspectFuncGetRecordsByJetDrop   func(jetDropID models.JetDropID, fromIndex *string, recordType *string, limit int, offset int)
	afterGetRecordsByJetDropCounter  uint64
	beforeGetRecordsByJetDropCounter uint64
	GetRecordsByJetDropMock          mStorageMockGetRecordsByJetDrop

	funcSaveJetDropData          func(jetDrop models.JetDrop, records []models.Record) (err error)
	inspectFuncSaveJetDropData   func(jetDrop models.JetDrop, records []models.Record)
	afterSaveJetDropDataCounter  uint64
	beforeSaveJetDropDataCounter uint64
	SaveJetDropDataMock          mStorageMockSaveJetDropData

	funcSavePulse          func(pulse models.Pulse) (err error)
	inspectFuncSavePulse   func(pulse models.Pulse)
	afterSavePulseCounter  uint64
	beforeSavePulseCounter uint64
	SavePulseMock          mStorageMockSavePulse
}

// NewStorageMock returns a mock for interfaces.Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CompletePulseMock = mStorageMockCompletePulse{mock: m}
	m.CompletePulseMock.callArgs = []*StorageMockCompletePulseParams{}

	m.GetAmountsMock = mStorageMockGetAmounts{mock: m}
	m.GetAmountsMock.callArgs = []*StorageMockGetAmountsParams{}

	m.GetIncompletePulsesMock = mStorageMockGetIncompletePulses{mock: m}

	m.GetJetDropByIDMock = mStorageMockGetJetDropByID{mock: m}
	m.GetJetDropByIDMock.callArgs = []*StorageMockGetJetDropByIDParams{}

	m.GetJetDropsMock = mStorageMockGetJetDrops{mock: m}
	m.GetJetDropsMock.callArgs = []*StorageMockGetJetDropsParams{}

	m.GetJetDropsWithParamsMock = mStorageMockGetJetDropsWithParams{mock: m}
	m.GetJetDropsWithParamsMock.callArgs = []*StorageMockGetJetDropsWithParamsParams{}

	m.GetLifelineMock = mStorageMockGetLifeline{mock: m}
	m.GetLifelineMock.callArgs = []*StorageMockGetLifelineParams{}

	m.GetPulseMock = mStorageMockGetPulse{mock: m}
	m.GetPulseMock.callArgs = []*StorageMockGetPulseParams{}

	m.GetPulsesMock = mStorageMockGetPulses{mock: m}
	m.GetPulsesMock.callArgs = []*StorageMockGetPulsesParams{}

	m.GetRecordMock = mStorageMockGetRecord{mock: m}
	m.GetRecordMock.callArgs = []*StorageMockGetRecordParams{}

	m.GetRecordsByJetDropMock = mStorageMockGetRecordsByJetDrop{mock: m}
	m.GetRecordsByJetDropMock.callArgs = []*StorageMockGetRecordsByJetDropParams{}

	m.SaveJetDropDataMock = mStorageMockSaveJetDropData{mock: m}
	m.SaveJetDropDataMock.callArgs = []*StorageMockSaveJetDropDataParams{}

	m.SavePulseMock = mStorageMockSavePulse{mock: m}
	m.SavePulseMock.callArgs = []*StorageMockSavePulseParams{}

	return m
}

type mStorageMockCompletePulse struct {
	mock               *StorageMock
	defaultExpectation *StorageMockCompletePulseExpectation
	expectations       []*StorageMockCompletePulseExpectation

	callArgs []*StorageMockCompletePulseParams
	mutex    sync.RWMutex
}

// StorageMockCompletePulseExpectation specifies expectation struct of the Storage.CompletePulse
type StorageMockCompletePulseExpectation struct {
	mock    *StorageMock
	params  *StorageMockCompletePulseParams
	results *StorageMockCompletePulseResults
	Counter uint64
}

// StorageMockCompletePulseParams contains parameters of the Storage.CompletePulse
type StorageMockCompletePulseParams struct {
	pulseNumber int
}

// StorageMockCompletePulseResults contains results of the Storage.CompletePulse
type StorageMockCompletePulseResults struct {
	err error
}

// Expect sets up expected params for Storage.CompletePulse
func (mmCompletePulse *mStorageMockCompletePulse) Expect(pulseNumber int) *mStorageMockCompletePulse {
	if mmCompletePulse.mock.funcCompletePulse != nil {
		mmCompletePulse.mock.t.Fatalf("StorageMock.CompletePulse mock is already set by Set")
	}

	if mmCompletePulse.defaultExpectation == nil {
		mmCompletePulse.defaultExpectation = &StorageMockCompletePulseExpectation{}
	}

	mmCompletePulse.defaultExpectation.params = &StorageMockCompletePulseParams{pulseNumber}
	for _, e := range mmCompletePulse.expectations {
		if minimock.Equal(e.params, mmCompletePulse.defaultExpectation.params) {
			mmCompletePulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCompletePulse.defaultExpectation.params)
		}
	}

	return mmCompletePulse
}

// Inspect accepts an inspector function that has same arguments as the Storage.CompletePulse
func (mmCompletePulse *mStorageMockCompletePulse) Inspect(f func(pulseNumber int)) *mStorageMockCompletePulse {
	if mmCompletePulse.mock.inspectFuncCompletePulse != nil {
		mmCompletePulse.mock.t.Fatalf("Inspect function is already set for StorageMock.CompletePulse")
	}

	mmCompletePulse.mock.inspectFuncCompletePulse = f

	return mmCompletePulse
}

// Return sets up results that will be returned by Storage.CompletePulse
func (mmCompletePulse *mStorageMockCompletePulse) Return(err error) *StorageMock {
	if mmCompletePulse.mock.funcCompletePulse != nil {
		mmCompletePulse.mock.t.Fatalf("StorageMock.CompletePulse mock is already set by Set")
	}

	if mmCompletePulse.defaultExpectation == nil {
		mmCompletePulse.defaultExpectation = &StorageMockCompletePulseExpectation{mock: mmCompletePulse.mock}
	}
	mmCompletePulse.defaultExpectation.results = &StorageMockCompletePulseResults{err}
	return mmCompletePulse.mock
}

//Set uses given function f to mock the Storage.CompletePulse method
func (mmCompletePulse *mStorageMockCompletePulse) Set(f func(pulseNumber int) (err error)) *StorageMock {
	if mmCompletePulse.defaultExpectation != nil {
		mmCompletePulse.mock.t.Fatalf("Default expectation is already set for the Storage.CompletePulse method")
	}

	if len(mmCompletePulse.expectations) > 0 {
		mmCompletePulse.mock.t.Fatalf("Some expectations are already set for the Storage.CompletePulse method")
	}

	mmCompletePulse.mock.funcCompletePulse = f
	return mmCompletePulse.mock
}

// When sets expectation for the Storage.CompletePulse which will trigger the result defined by the following
// Then helper
func (mmCompletePulse *mStorageMockCompletePulse) When(pulseNumber int) *StorageMockCompletePulseExpectation {
	if mmCompletePulse.mock.funcCompletePulse != nil {
		mmCompletePulse.mock.t.Fatalf("StorageMock.CompletePulse mock is already set by Set")
	}

	expectation := &StorageMockCompletePulseExpectation{
		mock:   mmCompletePulse.mock,
		params: &StorageMockCompletePulseParams{pulseNumber},
	}
	mmCompletePulse.expectations = append(mmCompletePulse.expectations, expectation)
	return expectation
}

// Then sets up Storage.CompletePulse return parameters for the expectation previously defined by the When method
func (e *StorageMockCompletePulseExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockCompletePulseResults{err}
	return e.mock
}

// CompletePulse implements interfaces.Storage
func (mmCompletePulse *StorageMock) CompletePulse(pulseNumber int) (err error) {
	mm_atomic.AddUint64(&mmCompletePulse.beforeCompletePulseCounter, 1)
	defer mm_atomic.AddUint64(&mmCompletePulse.afterCompletePulseCounter, 1)

	if mmCompletePulse.inspectFuncCompletePulse != nil {
		mmCompletePulse.inspectFuncCompletePulse(pulseNumber)
	}

	mm_params := &StorageMockCompletePulseParams{pulseNumber}

	// Record call args
	mmCompletePulse.CompletePulseMock.mutex.Lock()
	mmCompletePulse.CompletePulseMock.callArgs = append(mmCompletePulse.CompletePulseMock.callArgs, mm_params)
	mmCompletePulse.CompletePulseMock.mutex.Unlock()

	for _, e := range mmCompletePulse.CompletePulseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCompletePulse.CompletePulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCompletePulse.CompletePulseMock.defaultExpectation.Counter, 1)
		mm_want := mmCompletePulse.CompletePulseMock.defaultExpectation.params
		mm_got := StorageMockCompletePulseParams{pulseNumber}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCompletePulse.t.Errorf("StorageMock.CompletePulse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCompletePulse.CompletePulseMock.defaultExpectation.results
		if mm_results == nil {
			mmCompletePulse.t.Fatal("No results are set for the StorageMock.CompletePulse")
		}
		return (*mm_results).err
	}
	if mmCompletePulse.funcCompletePulse != nil {
		return mmCompletePulse.funcCompletePulse(pulseNumber)
	}
	mmCompletePulse.t.Fatalf("Unexpected call to StorageMock.CompletePulse. %v", pulseNumber)
	return
}

// CompletePulseAfterCounter returns a count of finished StorageMock.CompletePulse invocations
func (mmCompletePulse *StorageMock) CompletePulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompletePulse.afterCompletePulseCounter)
}

// CompletePulseBeforeCounter returns a count of StorageMock.CompletePulse invocations
func (mmCompletePulse *StorageMock) CompletePulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompletePulse.beforeCompletePulseCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.CompletePulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCompletePulse *mStorageMockCompletePulse) Calls() []*StorageMockCompletePulseParams {
	mmCompletePulse.mutex.RLock()

	argCopy := make([]*StorageMockCompletePulseParams, len(mmCompletePulse.callArgs))
	copy(argCopy, mmCompletePulse.callArgs)

	mmCompletePulse.mutex.RUnlock()

	return argCopy
}

// MinimockCompletePulseDone returns true if the count of the CompletePulse invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCompletePulseDone() bool {
	for _, e := range m.CompletePulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CompletePulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCompletePulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompletePulse != nil && mm_atomic.LoadUint64(&m.afterCompletePulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCompletePulseInspect logs each unmet expectation
func (m *StorageMock) MinimockCompletePulseInspect() {
	for _, e := range m.CompletePulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.CompletePulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CompletePulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCompletePulseCounter) < 1 {
		if m.CompletePulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.CompletePulse")
		} else {
			m.t.Errorf("Expected call to StorageMock.CompletePulse with params: %#v", *m.CompletePulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompletePulse != nil && mm_atomic.LoadUint64(&m.afterCompletePulseCounter) < 1 {
		m.t.Error("Expected call to StorageMock.CompletePulse")
	}
}

type mStorageMockGetAmounts struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetAmountsExpectation
	expectations       []*StorageMockGetAmountsExpectation

	callArgs []*StorageMockGetAmountsParams
	mutex    sync.RWMutex
}

// StorageMockGetAmountsExpectation specifies expectation struct of the Storage.GetAmounts
type StorageMockGetAmountsExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetAmountsParams
	results *StorageMockGetAmountsResults
	Counter uint64
}

// StorageMockGetAmountsParams contains parameters of the Storage.GetAmounts
type StorageMockGetAmountsParams struct {
	pulseNumber int
}

// StorageMockGetAmountsResults contains results of the Storage.GetAmounts
type StorageMockGetAmountsResults struct {
	jdAmount int64
	rAmount  int64
	err      error
}

// Expect sets up expected params for Storage.GetAmounts
func (mmGetAmounts *mStorageMockGetAmounts) Expect(pulseNumber int) *mStorageMockGetAmounts {
	if mmGetAmounts.mock.funcGetAmounts != nil {
		mmGetAmounts.mock.t.Fatalf("StorageMock.GetAmounts mock is already set by Set")
	}

	if mmGetAmounts.defaultExpectation == nil {
		mmGetAmounts.defaultExpectation = &StorageMockGetAmountsExpectation{}
	}

	mmGetAmounts.defaultExpectation.params = &StorageMockGetAmountsParams{pulseNumber}
	for _, e := range mmGetAmounts.expectations {
		if minimock.Equal(e.params, mmGetAmounts.defaultExpectation.params) {
			mmGetAmounts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAmounts.defaultExpectation.params)
		}
	}

	return mmGetAmounts
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetAmounts
func (mmGetAmounts *mStorageMockGetAmounts) Inspect(f func(pulseNumber int)) *mStorageMockGetAmounts {
	if mmGetAmounts.mock.inspectFuncGetAmounts != nil {
		mmGetAmounts.mock.t.Fatalf("Inspect function is already set for StorageMock.GetAmounts")
	}

	mmGetAmounts.mock.inspectFuncGetAmounts = f

	return mmGetAmounts
}

// Return sets up results that will be returned by Storage.GetAmounts
func (mmGetAmounts *mStorageMockGetAmounts) Return(jdAmount int64, rAmount int64, err error) *StorageMock {
	if mmGetAmounts.mock.funcGetAmounts != nil {
		mmGetAmounts.mock.t.Fatalf("StorageMock.GetAmounts mock is already set by Set")
	}

	if mmGetAmounts.defaultExpectation == nil {
		mmGetAmounts.defaultExpectation = &StorageMockGetAmountsExpectation{mock: mmGetAmounts.mock}
	}
	mmGetAmounts.defaultExpectation.results = &StorageMockGetAmountsResults{jdAmount, rAmount, err}
	return mmGetAmounts.mock
}

//Set uses given function f to mock the Storage.GetAmounts method
func (mmGetAmounts *mStorageMockGetAmounts) Set(f func(pulseNumber int) (jdAmount int64, rAmount int64, err error)) *StorageMock {
	if mmGetAmounts.defaultExpectation != nil {
		mmGetAmounts.mock.t.Fatalf("Default expectation is already set for the Storage.GetAmounts method")
	}

	if len(mmGetAmounts.expectations) > 0 {
		mmGetAmounts.mock.t.Fatalf("Some expectations are already set for the Storage.GetAmounts method")
	}

	mmGetAmounts.mock.funcGetAmounts = f
	return mmGetAmounts.mock
}

// When sets expectation for the Storage.GetAmounts which will trigger the result defined by the following
// Then helper
func (mmGetAmounts *mStorageMockGetAmounts) When(pulseNumber int) *StorageMockGetAmountsExpectation {
	if mmGetAmounts.mock.funcGetAmounts != nil {
		mmGetAmounts.mock.t.Fatalf("StorageMock.GetAmounts mock is already set by Set")
	}

	expectation := &StorageMockGetAmountsExpectation{
		mock:   mmGetAmounts.mock,
		params: &StorageMockGetAmountsParams{pulseNumber},
	}
	mmGetAmounts.expectations = append(mmGetAmounts.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetAmounts return parameters for the expectation previously defined by the When method
func (e *StorageMockGetAmountsExpectation) Then(jdAmount int64, rAmount int64, err error) *StorageMock {
	e.results = &StorageMockGetAmountsResults{jdAmount, rAmount, err}
	return e.mock
}

// GetAmounts implements interfaces.Storage
func (mmGetAmounts *StorageMock) GetAmounts(pulseNumber int) (jdAmount int64, rAmount int64, err error) {
	mm_atomic.AddUint64(&mmGetAmounts.beforeGetAmountsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAmounts.afterGetAmountsCounter, 1)

	if mmGetAmounts.inspectFuncGetAmounts != nil {
		mmGetAmounts.inspectFuncGetAmounts(pulseNumber)
	}

	mm_params := &StorageMockGetAmountsParams{pulseNumber}

	// Record call args
	mmGetAmounts.GetAmountsMock.mutex.Lock()
	mmGetAmounts.GetAmountsMock.callArgs = append(mmGetAmounts.GetAmountsMock.callArgs, mm_params)
	mmGetAmounts.GetAmountsMock.mutex.Unlock()

	for _, e := range mmGetAmounts.GetAmountsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.jdAmount, e.results.rAmount, e.results.err
		}
	}

	if mmGetAmounts.GetAmountsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAmounts.GetAmountsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAmounts.GetAmountsMock.defaultExpectation.params
		mm_got := StorageMockGetAmountsParams{pulseNumber}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAmounts.t.Errorf("StorageMock.GetAmounts got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAmounts.GetAmountsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAmounts.t.Fatal("No results are set for the StorageMock.GetAmounts")
		}
		return (*mm_results).jdAmount, (*mm_results).rAmount, (*mm_results).err
	}
	if mmGetAmounts.funcGetAmounts != nil {
		return mmGetAmounts.funcGetAmounts(pulseNumber)
	}
	mmGetAmounts.t.Fatalf("Unexpected call to StorageMock.GetAmounts. %v", pulseNumber)
	return
}

// GetAmountsAfterCounter returns a count of finished StorageMock.GetAmounts invocations
func (mmGetAmounts *StorageMock) GetAmountsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAmounts.afterGetAmountsCounter)
}

// GetAmountsBeforeCounter returns a count of StorageMock.GetAmounts invocations
func (mmGetAmounts *StorageMock) GetAmountsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAmounts.beforeGetAmountsCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetAmounts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAmounts *mStorageMockGetAmounts) Calls() []*StorageMockGetAmountsParams {
	mmGetAmounts.mutex.RLock()

	argCopy := make([]*StorageMockGetAmountsParams, len(mmGetAmounts.callArgs))
	copy(argCopy, mmGetAmounts.callArgs)

	mmGetAmounts.mutex.RUnlock()

	return argCopy
}

// MinimockGetAmountsDone returns true if the count of the GetAmounts invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetAmountsDone() bool {
	for _, e := range m.GetAmountsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAmountsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAmountsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAmounts != nil && mm_atomic.LoadUint64(&m.afterGetAmountsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAmountsInspect logs each unmet expectation
func (m *StorageMock) MinimockGetAmountsInspect() {
	for _, e := range m.GetAmountsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetAmounts with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAmountsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAmountsCounter) < 1 {
		if m.GetAmountsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetAmounts")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetAmounts with params: %#v", *m.GetAmountsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAmounts != nil && mm_atomic.LoadUint64(&m.afterGetAmountsCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetAmounts")
	}
}

type mStorageMockGetIncompletePulses struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetIncompletePulsesExpectation
	expectations       []*StorageMockGetIncompletePulsesExpectation
}

// StorageMockGetIncompletePulsesExpectation specifies expectation struct of the Storage.GetIncompletePulses
type StorageMockGetIncompletePulsesExpectation struct {
	mock *StorageMock

	results *StorageMockGetIncompletePulsesResults
	Counter uint64
}

// StorageMockGetIncompletePulsesResults contains results of the Storage.GetIncompletePulses
type StorageMockGetIncompletePulsesResults struct {
	pa1 []models.Pulse
	err error
}

// Expect sets up expected params for Storage.GetIncompletePulses
func (mmGetIncompletePulses *mStorageMockGetIncompletePulses) Expect() *mStorageMockGetIncompletePulses {
	if mmGetIncompletePulses.mock.funcGetIncompletePulses != nil {
		mmGetIncompletePulses.mock.t.Fatalf("StorageMock.GetIncompletePulses mock is already set by Set")
	}

	if mmGetIncompletePulses.defaultExpectation == nil {
		mmGetIncompletePulses.defaultExpectation = &StorageMockGetIncompletePulsesExpectation{}
	}

	return mmGetIncompletePulses
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetIncompletePulses
func (mmGetIncompletePulses *mStorageMockGetIncompletePulses) Inspect(f func()) *mStorageMockGetIncompletePulses {
	if mmGetIncompletePulses.mock.inspectFuncGetIncompletePulses != nil {
		mmGetIncompletePulses.mock.t.Fatalf("Inspect function is already set for StorageMock.GetIncompletePulses")
	}

	mmGetIncompletePulses.mock.inspectFuncGetIncompletePulses = f

	return mmGetIncompletePulses
}

// Return sets up results that will be returned by Storage.GetIncompletePulses
func (mmGetIncompletePulses *mStorageMockGetIncompletePulses) Return(pa1 []models.Pulse, err error) *StorageMock {
	if mmGetIncompletePulses.mock.funcGetIncompletePulses != nil {
		mmGetIncompletePulses.mock.t.Fatalf("StorageMock.GetIncompletePulses mock is already set by Set")
	}

	if mmGetIncompletePulses.defaultExpectation == nil {
		mmGetIncompletePulses.defaultExpectation = &StorageMockGetIncompletePulsesExpectation{mock: mmGetIncompletePulses.mock}
	}
	mmGetIncompletePulses.defaultExpectation.results = &StorageMockGetIncompletePulsesResults{pa1, err}
	return mmGetIncompletePulses.mock
}

//Set uses given function f to mock the Storage.GetIncompletePulses method
func (mmGetIncompletePulses *mStorageMockGetIncompletePulses) Set(f func() (pa1 []models.Pulse, err error)) *StorageMock {
	if mmGetIncompletePulses.defaultExpectation != nil {
		mmGetIncompletePulses.mock.t.Fatalf("Default expectation is already set for the Storage.GetIncompletePulses method")
	}

	if len(mmGetIncompletePulses.expectations) > 0 {
		mmGetIncompletePulses.mock.t.Fatalf("Some expectations are already set for the Storage.GetIncompletePulses method")
	}

	mmGetIncompletePulses.mock.funcGetIncompletePulses = f
	return mmGetIncompletePulses.mock
}

// GetIncompletePulses implements interfaces.Storage
func (mmGetIncompletePulses *StorageMock) GetIncompletePulses() (pa1 []models.Pulse, err error) {
	mm_atomic.AddUint64(&mmGetIncompletePulses.beforeGetIncompletePulsesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetIncompletePulses.afterGetIncompletePulsesCounter, 1)

	if mmGetIncompletePulses.inspectFuncGetIncompletePulses != nil {
		mmGetIncompletePulses.inspectFuncGetIncompletePulses()
	}

	if mmGetIncompletePulses.GetIncompletePulsesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetIncompletePulses.GetIncompletePulsesMock.defaultExpectation.Counter, 1)

		mm_results := mmGetIncompletePulses.GetIncompletePulsesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetIncompletePulses.t.Fatal("No results are set for the StorageMock.GetIncompletePulses")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetIncompletePulses.funcGetIncompletePulses != nil {
		return mmGetIncompletePulses.funcGetIncompletePulses()
	}
	mmGetIncompletePulses.t.Fatalf("Unexpected call to StorageMock.GetIncompletePulses.")
	return
}

// GetIncompletePulsesAfterCounter returns a count of finished StorageMock.GetIncompletePulses invocations
func (mmGetIncompletePulses *StorageMock) GetIncompletePulsesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIncompletePulses.afterGetIncompletePulsesCounter)
}

// GetIncompletePulsesBeforeCounter returns a count of StorageMock.GetIncompletePulses invocations
func (mmGetIncompletePulses *StorageMock) GetIncompletePulsesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIncompletePulses.beforeGetIncompletePulsesCounter)
}

// MinimockGetIncompletePulsesDone returns true if the count of the GetIncompletePulses invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetIncompletePulsesDone() bool {
	for _, e := range m.GetIncompletePulsesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetIncompletePulsesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetIncompletePulsesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIncompletePulses != nil && mm_atomic.LoadUint64(&m.afterGetIncompletePulsesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetIncompletePulsesInspect logs each unmet expectation
func (m *StorageMock) MinimockGetIncompletePulsesInspect() {
	for _, e := range m.GetIncompletePulsesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.GetIncompletePulses")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetIncompletePulsesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetIncompletePulsesCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetIncompletePulses")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIncompletePulses != nil && mm_atomic.LoadUint64(&m.afterGetIncompletePulsesCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetIncompletePulses")
	}
}

type mStorageMockGetJetDropByID struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetJetDropByIDExpectation
	expectations       []*StorageMockGetJetDropByIDExpectation

	callArgs []*StorageMockGetJetDropByIDParams
	mutex    sync.RWMutex
}

// StorageMockGetJetDropByIDExpectation specifies expectation struct of the Storage.GetJetDropByID
type StorageMockGetJetDropByIDExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetJetDropByIDParams
	results *StorageMockGetJetDropByIDResults
	Counter uint64
}

// StorageMockGetJetDropByIDParams contains parameters of the Storage.GetJetDropByID
type StorageMockGetJetDropByIDParams struct {
	id models.JetDropID
}

// StorageMockGetJetDropByIDResults contains results of the Storage.GetJetDropByID
type StorageMockGetJetDropByIDResults struct {
	j1  models.JetDrop
	err error
}

// Expect sets up expected params for Storage.GetJetDropByID
func (mmGetJetDropByID *mStorageMockGetJetDropByID) Expect(id models.JetDropID) *mStorageMockGetJetDropByID {
	if mmGetJetDropByID.mock.funcGetJetDropByID != nil {
		mmGetJetDropByID.mock.t.Fatalf("StorageMock.GetJetDropByID mock is already set by Set")
	}

	if mmGetJetDropByID.defaultExpectation == nil {
		mmGetJetDropByID.defaultExpectation = &StorageMockGetJetDropByIDExpectation{}
	}

	mmGetJetDropByID.defaultExpectation.params = &StorageMockGetJetDropByIDParams{id}
	for _, e := range mmGetJetDropByID.expectations {
		if minimock.Equal(e.params, mmGetJetDropByID.defaultExpectation.params) {
			mmGetJetDropByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetJetDropByID.defaultExpectation.params)
		}
	}

	return mmGetJetDropByID
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetJetDropByID
func (mmGetJetDropByID *mStorageMockGetJetDropByID) Inspect(f func(id models.JetDropID)) *mStorageMockGetJetDropByID {
	if mmGetJetDropByID.mock.inspectFuncGetJetDropByID != nil {
		mmGetJetDropByID.mock.t.Fatalf("Inspect function is already set for StorageMock.GetJetDropByID")
	}

	mmGetJetDropByID.mock.inspectFuncGetJetDropByID = f

	return mmGetJetDropByID
}

// Return sets up results that will be returned by Storage.GetJetDropByID
func (mmGetJetDropByID *mStorageMockGetJetDropByID) Return(j1 models.JetDrop, err error) *StorageMock {
	if mmGetJetDropByID.mock.funcGetJetDropByID != nil {
		mmGetJetDropByID.mock.t.Fatalf("StorageMock.GetJetDropByID mock is already set by Set")
	}

	if mmGetJetDropByID.defaultExpectation == nil {
		mmGetJetDropByID.defaultExpectation = &StorageMockGetJetDropByIDExpectation{mock: mmGetJetDropByID.mock}
	}
	mmGetJetDropByID.defaultExpectation.results = &StorageMockGetJetDropByIDResults{j1, err}
	return mmGetJetDropByID.mock
}

//Set uses given function f to mock the Storage.GetJetDropByID method
func (mmGetJetDropByID *mStorageMockGetJetDropByID) Set(f func(id models.JetDropID) (j1 models.JetDrop, err error)) *StorageMock {
	if mmGetJetDropByID.defaultExpectation != nil {
		mmGetJetDropByID.mock.t.Fatalf("Default expectation is already set for the Storage.GetJetDropByID method")
	}

	if len(mmGetJetDropByID.expectations) > 0 {
		mmGetJetDropByID.mock.t.Fatalf("Some expectations are already set for the Storage.GetJetDropByID method")
	}

	mmGetJetDropByID.mock.funcGetJetDropByID = f
	return mmGetJetDropByID.mock
}

// When sets expectation for the Storage.GetJetDropByID which will trigger the result defined by the following
// Then helper
func (mmGetJetDropByID *mStorageMockGetJetDropByID) When(id models.JetDropID) *StorageMockGetJetDropByIDExpectation {
	if mmGetJetDropByID.mock.funcGetJetDropByID != nil {
		mmGetJetDropByID.mock.t.Fatalf("StorageMock.GetJetDropByID mock is already set by Set")
	}

	expectation := &StorageMockGetJetDropByIDExpectation{
		mock:   mmGetJetDropByID.mock,
		params: &StorageMockGetJetDropByIDParams{id},
	}
	mmGetJetDropByID.expectations = append(mmGetJetDropByID.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetJetDropByID return parameters for the expectation previously defined by the When method
func (e *StorageMockGetJetDropByIDExpectation) Then(j1 models.JetDrop, err error) *StorageMock {
	e.results = &StorageMockGetJetDropByIDResults{j1, err}
	return e.mock
}

// GetJetDropByID implements interfaces.Storage
func (mmGetJetDropByID *StorageMock) GetJetDropByID(id models.JetDropID) (j1 models.JetDrop, err error) {
	mm_atomic.AddUint64(&mmGetJetDropByID.beforeGetJetDropByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetJetDropByID.afterGetJetDropByIDCounter, 1)

	if mmGetJetDropByID.inspectFuncGetJetDropByID != nil {
		mmGetJetDropByID.inspectFuncGetJetDropByID(id)
	}

	mm_params := &StorageMockGetJetDropByIDParams{id}

	// Record call args
	mmGetJetDropByID.GetJetDropByIDMock.mutex.Lock()
	mmGetJetDropByID.GetJetDropByIDMock.callArgs = append(mmGetJetDropByID.GetJetDropByIDMock.callArgs, mm_params)
	mmGetJetDropByID.GetJetDropByIDMock.mutex.Unlock()

	for _, e := range mmGetJetDropByID.GetJetDropByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.j1, e.results.err
		}
	}

	if mmGetJetDropByID.GetJetDropByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetJetDropByID.GetJetDropByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetJetDropByID.GetJetDropByIDMock.defaultExpectation.params
		mm_got := StorageMockGetJetDropByIDParams{id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetJetDropByID.t.Errorf("StorageMock.GetJetDropByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetJetDropByID.GetJetDropByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetJetDropByID.t.Fatal("No results are set for the StorageMock.GetJetDropByID")
		}
		return (*mm_results).j1, (*mm_results).err
	}
	if mmGetJetDropByID.funcGetJetDropByID != nil {
		return mmGetJetDropByID.funcGetJetDropByID(id)
	}
	mmGetJetDropByID.t.Fatalf("Unexpected call to StorageMock.GetJetDropByID. %v", id)
	return
}

// GetJetDropByIDAfterCounter returns a count of finished StorageMock.GetJetDropByID invocations
func (mmGetJetDropByID *StorageMock) GetJetDropByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetJetDropByID.afterGetJetDropByIDCounter)
}

// GetJetDropByIDBeforeCounter returns a count of StorageMock.GetJetDropByID invocations
func (mmGetJetDropByID *StorageMock) GetJetDropByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetJetDropByID.beforeGetJetDropByIDCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetJetDropByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetJetDropByID *mStorageMockGetJetDropByID) Calls() []*StorageMockGetJetDropByIDParams {
	mmGetJetDropByID.mutex.RLock()

	argCopy := make([]*StorageMockGetJetDropByIDParams, len(mmGetJetDropByID.callArgs))
	copy(argCopy, mmGetJetDropByID.callArgs)

	mmGetJetDropByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetJetDropByIDDone returns true if the count of the GetJetDropByID invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetJetDropByIDDone() bool {
	for _, e := range m.GetJetDropByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetJetDropByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetJetDropByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetJetDropByID != nil && mm_atomic.LoadUint64(&m.afterGetJetDropByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetJetDropByIDInspect logs each unmet expectation
func (m *StorageMock) MinimockGetJetDropByIDInspect() {
	for _, e := range m.GetJetDropByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetJetDropByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetJetDropByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetJetDropByIDCounter) < 1 {
		if m.GetJetDropByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetJetDropByID")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetJetDropByID with params: %#v", *m.GetJetDropByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetJetDropByID != nil && mm_atomic.LoadUint64(&m.afterGetJetDropByIDCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetJetDropByID")
	}
}

type mStorageMockGetJetDrops struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetJetDropsExpectation
	expectations       []*StorageMockGetJetDropsExpectation

	callArgs []*StorageMockGetJetDropsParams
	mutex    sync.RWMutex
}

// StorageMockGetJetDropsExpectation specifies expectation struct of the Storage.GetJetDrops
type StorageMockGetJetDropsExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetJetDropsParams
	results *StorageMockGetJetDropsResults
	Counter uint64
}

// StorageMockGetJetDropsParams contains parameters of the Storage.GetJetDrops
type StorageMockGetJetDropsParams struct {
	pulse models.Pulse
}

// StorageMockGetJetDropsResults contains results of the Storage.GetJetDrops
type StorageMockGetJetDropsResults struct {
	ja1 []models.JetDrop
	err error
}

// Expect sets up expected params for Storage.GetJetDrops
func (mmGetJetDrops *mStorageMockGetJetDrops) Expect(pulse models.Pulse) *mStorageMockGetJetDrops {
	if mmGetJetDrops.mock.funcGetJetDrops != nil {
		mmGetJetDrops.mock.t.Fatalf("StorageMock.GetJetDrops mock is already set by Set")
	}

	if mmGetJetDrops.defaultExpectation == nil {
		mmGetJetDrops.defaultExpectation = &StorageMockGetJetDropsExpectation{}
	}

	mmGetJetDrops.defaultExpectation.params = &StorageMockGetJetDropsParams{pulse}
	for _, e := range mmGetJetDrops.expectations {
		if minimock.Equal(e.params, mmGetJetDrops.defaultExpectation.params) {
			mmGetJetDrops.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetJetDrops.defaultExpectation.params)
		}
	}

	return mmGetJetDrops
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetJetDrops
func (mmGetJetDrops *mStorageMockGetJetDrops) Inspect(f func(pulse models.Pulse)) *mStorageMockGetJetDrops {
	if mmGetJetDrops.mock.inspectFuncGetJetDrops != nil {
		mmGetJetDrops.mock.t.Fatalf("Inspect function is already set for StorageMock.GetJetDrops")
	}

	mmGetJetDrops.mock.inspectFuncGetJetDrops = f

	return mmGetJetDrops
}

// Return sets up results that will be returned by Storage.GetJetDrops
func (mmGetJetDrops *mStorageMockGetJetDrops) Return(ja1 []models.JetDrop, err error) *StorageMock {
	if mmGetJetDrops.mock.funcGetJetDrops != nil {
		mmGetJetDrops.mock.t.Fatalf("StorageMock.GetJetDrops mock is already set by Set")
	}

	if mmGetJetDrops.defaultExpectation == nil {
		mmGetJetDrops.defaultExpectation = &StorageMockGetJetDropsExpectation{mock: mmGetJetDrops.mock}
	}
	mmGetJetDrops.defaultExpectation.results = &StorageMockGetJetDropsResults{ja1, err}
	return mmGetJetDrops.mock
}

//Set uses given function f to mock the Storage.GetJetDrops method
func (mmGetJetDrops *mStorageMockGetJetDrops) Set(f func(pulse models.Pulse) (ja1 []models.JetDrop, err error)) *StorageMock {
	if mmGetJetDrops.defaultExpectation != nil {
		mmGetJetDrops.mock.t.Fatalf("Default expectation is already set for the Storage.GetJetDrops method")
	}

	if len(mmGetJetDrops.expectations) > 0 {
		mmGetJetDrops.mock.t.Fatalf("Some expectations are already set for the Storage.GetJetDrops method")
	}

	mmGetJetDrops.mock.funcGetJetDrops = f
	return mmGetJetDrops.mock
}

// When sets expectation for the Storage.GetJetDrops which will trigger the result defined by the following
// Then helper
func (mmGetJetDrops *mStorageMockGetJetDrops) When(pulse models.Pulse) *StorageMockGetJetDropsExpectation {
	if mmGetJetDrops.mock.funcGetJetDrops != nil {
		mmGetJetDrops.mock.t.Fatalf("StorageMock.GetJetDrops mock is already set by Set")
	}

	expectation := &StorageMockGetJetDropsExpectation{
		mock:   mmGetJetDrops.mock,
		params: &StorageMockGetJetDropsParams{pulse},
	}
	mmGetJetDrops.expectations = append(mmGetJetDrops.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetJetDrops return parameters for the expectation previously defined by the When method
func (e *StorageMockGetJetDropsExpectation) Then(ja1 []models.JetDrop, err error) *StorageMock {
	e.results = &StorageMockGetJetDropsResults{ja1, err}
	return e.mock
}

// GetJetDrops implements interfaces.Storage
func (mmGetJetDrops *StorageMock) GetJetDrops(pulse models.Pulse) (ja1 []models.JetDrop, err error) {
	mm_atomic.AddUint64(&mmGetJetDrops.beforeGetJetDropsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetJetDrops.afterGetJetDropsCounter, 1)

	if mmGetJetDrops.inspectFuncGetJetDrops != nil {
		mmGetJetDrops.inspectFuncGetJetDrops(pulse)
	}

	mm_params := &StorageMockGetJetDropsParams{pulse}

	// Record call args
	mmGetJetDrops.GetJetDropsMock.mutex.Lock()
	mmGetJetDrops.GetJetDropsMock.callArgs = append(mmGetJetDrops.GetJetDropsMock.callArgs, mm_params)
	mmGetJetDrops.GetJetDropsMock.mutex.Unlock()

	for _, e := range mmGetJetDrops.GetJetDropsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ja1, e.results.err
		}
	}

	if mmGetJetDrops.GetJetDropsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetJetDrops.GetJetDropsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetJetDrops.GetJetDropsMock.defaultExpectation.params
		mm_got := StorageMockGetJetDropsParams{pulse}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetJetDrops.t.Errorf("StorageMock.GetJetDrops got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetJetDrops.GetJetDropsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetJetDrops.t.Fatal("No results are set for the StorageMock.GetJetDrops")
		}
		return (*mm_results).ja1, (*mm_results).err
	}
	if mmGetJetDrops.funcGetJetDrops != nil {
		return mmGetJetDrops.funcGetJetDrops(pulse)
	}
	mmGetJetDrops.t.Fatalf("Unexpected call to StorageMock.GetJetDrops. %v", pulse)
	return
}

// GetJetDropsAfterCounter returns a count of finished StorageMock.GetJetDrops invocations
func (mmGetJetDrops *StorageMock) GetJetDropsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetJetDrops.afterGetJetDropsCounter)
}

// GetJetDropsBeforeCounter returns a count of StorageMock.GetJetDrops invocations
func (mmGetJetDrops *StorageMock) GetJetDropsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetJetDrops.beforeGetJetDropsCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetJetDrops.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetJetDrops *mStorageMockGetJetDrops) Calls() []*StorageMockGetJetDropsParams {
	mmGetJetDrops.mutex.RLock()

	argCopy := make([]*StorageMockGetJetDropsParams, len(mmGetJetDrops.callArgs))
	copy(argCopy, mmGetJetDrops.callArgs)

	mmGetJetDrops.mutex.RUnlock()

	return argCopy
}

// MinimockGetJetDropsDone returns true if the count of the GetJetDrops invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetJetDropsDone() bool {
	for _, e := range m.GetJetDropsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetJetDropsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetJetDropsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetJetDrops != nil && mm_atomic.LoadUint64(&m.afterGetJetDropsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetJetDropsInspect logs each unmet expectation
func (m *StorageMock) MinimockGetJetDropsInspect() {
	for _, e := range m.GetJetDropsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetJetDrops with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetJetDropsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetJetDropsCounter) < 1 {
		if m.GetJetDropsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetJetDrops")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetJetDrops with params: %#v", *m.GetJetDropsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetJetDrops != nil && mm_atomic.LoadUint64(&m.afterGetJetDropsCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetJetDrops")
	}
}

type mStorageMockGetJetDropsWithParams struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetJetDropsWithParamsExpectation
	expectations       []*StorageMockGetJetDropsWithParamsExpectation

	callArgs []*StorageMockGetJetDropsWithParamsParams
	mutex    sync.RWMutex
}

// StorageMockGetJetDropsWithParamsExpectation specifies expectation struct of the Storage.GetJetDropsWithParams
type StorageMockGetJetDropsWithParamsExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetJetDropsWithParamsParams
	results *StorageMockGetJetDropsWithParamsResults
	Counter uint64
}

// StorageMockGetJetDropsWithParamsParams contains parameters of the Storage.GetJetDropsWithParams
type StorageMockGetJetDropsWithParamsParams struct {
	pulse         models.Pulse
	fromJetDropID *models.JetDropID
	limit         int
	offset        int
}

// StorageMockGetJetDropsWithParamsResults contains results of the Storage.GetJetDropsWithParams
type StorageMockGetJetDropsWithParamsResults struct {
	ja1 []models.JetDrop
	i1  int
	err error
}

// Expect sets up expected params for Storage.GetJetDropsWithParams
func (mmGetJetDropsWithParams *mStorageMockGetJetDropsWithParams) Expect(pulse models.Pulse, fromJetDropID *models.JetDropID, limit int, offset int) *mStorageMockGetJetDropsWithParams {
	if mmGetJetDropsWithParams.mock.funcGetJetDropsWithParams != nil {
		mmGetJetDropsWithParams.mock.t.Fatalf("StorageMock.GetJetDropsWithParams mock is already set by Set")
	}

	if mmGetJetDropsWithParams.defaultExpectation == nil {
		mmGetJetDropsWithParams.defaultExpectation = &StorageMockGetJetDropsWithParamsExpectation{}
	}

	mmGetJetDropsWithParams.defaultExpectation.params = &StorageMockGetJetDropsWithParamsParams{pulse, fromJetDropID, limit, offset}
	for _, e := range mmGetJetDropsWithParams.expectations {
		if minimock.Equal(e.params, mmGetJetDropsWithParams.defaultExpectation.params) {
			mmGetJetDropsWithParams.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetJetDropsWithParams.defaultExpectation.params)
		}
	}

	return mmGetJetDropsWithParams
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetJetDropsWithParams
func (mmGetJetDropsWithParams *mStorageMockGetJetDropsWithParams) Inspect(f func(pulse models.Pulse, fromJetDropID *models.JetDropID, limit int, offset int)) *mStorageMockGetJetDropsWithParams {
	if mmGetJetDropsWithParams.mock.inspectFuncGetJetDropsWithParams != nil {
		mmGetJetDropsWithParams.mock.t.Fatalf("Inspect function is already set for StorageMock.GetJetDropsWithParams")
	}

	mmGetJetDropsWithParams.mock.inspectFuncGetJetDropsWithParams = f

	return mmGetJetDropsWithParams
}

// Return sets up results that will be returned by Storage.GetJetDropsWithParams
func (mmGetJetDropsWithParams *mStorageMockGetJetDropsWithParams) Return(ja1 []models.JetDrop, i1 int, err error) *StorageMock {
	if mmGetJetDropsWithParams.mock.funcGetJetDropsWithParams != nil {
		mmGetJetDropsWithParams.mock.t.Fatalf("StorageMock.GetJetDropsWithParams mock is already set by Set")
	}

	if mmGetJetDropsWithParams.defaultExpectation == nil {
		mmGetJetDropsWithParams.defaultExpectation = &StorageMockGetJetDropsWithParamsExpectation{mock: mmGetJetDropsWithParams.mock}
	}
	mmGetJetDropsWithParams.defaultExpectation.results = &StorageMockGetJetDropsWithParamsResults{ja1, i1, err}
	return mmGetJetDropsWithParams.mock
}

//Set uses given function f to mock the Storage.GetJetDropsWithParams method
func (mmGetJetDropsWithParams *mStorageMockGetJetDropsWithParams) Set(f func(pulse models.Pulse, fromJetDropID *models.JetDropID, limit int, offset int) (ja1 []models.JetDrop, i1 int, err error)) *StorageMock {
	if mmGetJetDropsWithParams.defaultExpectation != nil {
		mmGetJetDropsWithParams.mock.t.Fatalf("Default expectation is already set for the Storage.GetJetDropsWithParams method")
	}

	if len(mmGetJetDropsWithParams.expectations) > 0 {
		mmGetJetDropsWithParams.mock.t.Fatalf("Some expectations are already set for the Storage.GetJetDropsWithParams method")
	}

	mmGetJetDropsWithParams.mock.funcGetJetDropsWithParams = f
	return mmGetJetDropsWithParams.mock
}

// When sets expectation for the Storage.GetJetDropsWithParams which will trigger the result defined by the following
// Then helper
func (mmGetJetDropsWithParams *mStorageMockGetJetDropsWithParams) When(pulse models.Pulse, fromJetDropID *models.JetDropID, limit int, offset int) *StorageMockGetJetDropsWithParamsExpectation {
	if mmGetJetDropsWithParams.mock.funcGetJetDropsWithParams != nil {
		mmGetJetDropsWithParams.mock.t.Fatalf("StorageMock.GetJetDropsWithParams mock is already set by Set")
	}

	expectation := &StorageMockGetJetDropsWithParamsExpectation{
		mock:   mmGetJetDropsWithParams.mock,
		params: &StorageMockGetJetDropsWithParamsParams{pulse, fromJetDropID, limit, offset},
	}
	mmGetJetDropsWithParams.expectations = append(mmGetJetDropsWithParams.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetJetDropsWithParams return parameters for the expectation previously defined by the When method
func (e *StorageMockGetJetDropsWithParamsExpectation) Then(ja1 []models.JetDrop, i1 int, err error) *StorageMock {
	e.results = &StorageMockGetJetDropsWithParamsResults{ja1, i1, err}
	return e.mock
}

// GetJetDropsWithParams implements interfaces.Storage
func (mmGetJetDropsWithParams *StorageMock) GetJetDropsWithParams(pulse models.Pulse, fromJetDropID *models.JetDropID, limit int, offset int) (ja1 []models.JetDrop, i1 int, err error) {
	mm_atomic.AddUint64(&mmGetJetDropsWithParams.beforeGetJetDropsWithParamsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetJetDropsWithParams.afterGetJetDropsWithParamsCounter, 1)

	if mmGetJetDropsWithParams.inspectFuncGetJetDropsWithParams != nil {
		mmGetJetDropsWithParams.inspectFuncGetJetDropsWithParams(pulse, fromJetDropID, limit, offset)
	}

	mm_params := &StorageMockGetJetDropsWithParamsParams{pulse, fromJetDropID, limit, offset}

	// Record call args
	mmGetJetDropsWithParams.GetJetDropsWithParamsMock.mutex.Lock()
	mmGetJetDropsWithParams.GetJetDropsWithParamsMock.callArgs = append(mmGetJetDropsWithParams.GetJetDropsWithParamsMock.callArgs, mm_params)
	mmGetJetDropsWithParams.GetJetDropsWithParamsMock.mutex.Unlock()

	for _, e := range mmGetJetDropsWithParams.GetJetDropsWithParamsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ja1, e.results.i1, e.results.err
		}
	}

	if mmGetJetDropsWithParams.GetJetDropsWithParamsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetJetDropsWithParams.GetJetDropsWithParamsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetJetDropsWithParams.GetJetDropsWithParamsMock.defaultExpectation.params
		mm_got := StorageMockGetJetDropsWithParamsParams{pulse, fromJetDropID, limit, offset}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetJetDropsWithParams.t.Errorf("StorageMock.GetJetDropsWithParams got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetJetDropsWithParams.GetJetDropsWithParamsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetJetDropsWithParams.t.Fatal("No results are set for the StorageMock.GetJetDropsWithParams")
		}
		return (*mm_results).ja1, (*mm_results).i1, (*mm_results).err
	}
	if mmGetJetDropsWithParams.funcGetJetDropsWithParams != nil {
		return mmGetJetDropsWithParams.funcGetJetDropsWithParams(pulse, fromJetDropID, limit, offset)
	}
	mmGetJetDropsWithParams.t.Fatalf("Unexpected call to StorageMock.GetJetDropsWithParams. %v %v %v %v", pulse, fromJetDropID, limit, offset)
	return
}

// GetJetDropsWithParamsAfterCounter returns a count of finished StorageMock.GetJetDropsWithParams invocations
func (mmGetJetDropsWithParams *StorageMock) GetJetDropsWithParamsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetJetDropsWithParams.afterGetJetDropsWithParamsCounter)
}

// GetJetDropsWithParamsBeforeCounter returns a count of StorageMock.GetJetDropsWithParams invocations
func (mmGetJetDropsWithParams *StorageMock) GetJetDropsWithParamsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetJetDropsWithParams.beforeGetJetDropsWithParamsCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetJetDropsWithParams.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetJetDropsWithParams *mStorageMockGetJetDropsWithParams) Calls() []*StorageMockGetJetDropsWithParamsParams {
	mmGetJetDropsWithParams.mutex.RLock()

	argCopy := make([]*StorageMockGetJetDropsWithParamsParams, len(mmGetJetDropsWithParams.callArgs))
	copy(argCopy, mmGetJetDropsWithParams.callArgs)

	mmGetJetDropsWithParams.mutex.RUnlock()

	return argCopy
}

// MinimockGetJetDropsWithParamsDone returns true if the count of the GetJetDropsWithParams invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetJetDropsWithParamsDone() bool {
	for _, e := range m.GetJetDropsWithParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetJetDropsWithParamsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetJetDropsWithParamsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetJetDropsWithParams != nil && mm_atomic.LoadUint64(&m.afterGetJetDropsWithParamsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetJetDropsWithParamsInspect logs each unmet expectation
func (m *StorageMock) MinimockGetJetDropsWithParamsInspect() {
	for _, e := range m.GetJetDropsWithParamsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetJetDropsWithParams with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetJetDropsWithParamsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetJetDropsWithParamsCounter) < 1 {
		if m.GetJetDropsWithParamsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetJetDropsWithParams")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetJetDropsWithParams with params: %#v", *m.GetJetDropsWithParamsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetJetDropsWithParams != nil && mm_atomic.LoadUint64(&m.afterGetJetDropsWithParamsCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetJetDropsWithParams")
	}
}

type mStorageMockGetLifeline struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetLifelineExpectation
	expectations       []*StorageMockGetLifelineExpectation

	callArgs []*StorageMockGetLifelineParams
	mutex    sync.RWMutex
}

// StorageMockGetLifelineExpectation specifies expectation struct of the Storage.GetLifeline
type StorageMockGetLifelineExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetLifelineParams
	results *StorageMockGetLifelineResults
	Counter uint64
}

// StorageMockGetLifelineParams contains parameters of the Storage.GetLifeline
type StorageMockGetLifelineParams struct {
	objRef        []byte
	fromIndex     *string
	pulseNumberLt *int
	pulseNumberGt *int
	timestampLte  *int
	timestampGte  *int
	limit         int
	offset        int
	sort          string
}

// StorageMockGetLifelineResults contains results of the Storage.GetLifeline
type StorageMockGetLifelineResults struct {
	ra1 []models.Record
	i1  int
	err error
}

// Expect sets up expected params for Storage.GetLifeline
func (mmGetLifeline *mStorageMockGetLifeline) Expect(objRef []byte, fromIndex *string, pulseNumberLt *int, pulseNumberGt *int, timestampLte *int, timestampGte *int, limit int, offset int, sort string) *mStorageMockGetLifeline {
	if mmGetLifeline.mock.funcGetLifeline != nil {
		mmGetLifeline.mock.t.Fatalf("StorageMock.GetLifeline mock is already set by Set")
	}

	if mmGetLifeline.defaultExpectation == nil {
		mmGetLifeline.defaultExpectation = &StorageMockGetLifelineExpectation{}
	}

	mmGetLifeline.defaultExpectation.params = &StorageMockGetLifelineParams{objRef, fromIndex, pulseNumberLt, pulseNumberGt, timestampLte, timestampGte, limit, offset, sort}
	for _, e := range mmGetLifeline.expectations {
		if minimock.Equal(e.params, mmGetLifeline.defaultExpectation.params) {
			mmGetLifeline.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLifeline.defaultExpectation.params)
		}
	}

	return mmGetLifeline
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetLifeline
func (mmGetLifeline *mStorageMockGetLifeline) Inspect(f func(objRef []byte, fromIndex *string, pulseNumberLt *int, pulseNumberGt *int, timestampLte *int, timestampGte *int, limit int, offset int, sort string)) *mStorageMockGetLifeline {
	if mmGetLifeline.mock.inspectFuncGetLifeline != nil {
		mmGetLifeline.mock.t.Fatalf("Inspect function is already set for StorageMock.GetLifeline")
	}

	mmGetLifeline.mock.inspectFuncGetLifeline = f

	return mmGetLifeline
}

// Return sets up results that will be returned by Storage.GetLifeline
func (mmGetLifeline *mStorageMockGetLifeline) Return(ra1 []models.Record, i1 int, err error) *StorageMock {
	if mmGetLifeline.mock.funcGetLifeline != nil {
		mmGetLifeline.mock.t.Fatalf("StorageMock.GetLifeline mock is already set by Set")
	}

	if mmGetLifeline.defaultExpectation == nil {
		mmGetLifeline.defaultExpectation = &StorageMockGetLifelineExpectation{mock: mmGetLifeline.mock}
	}
	mmGetLifeline.defaultExpectation.results = &StorageMockGetLifelineResults{ra1, i1, err}
	return mmGetLifeline.mock
}

//Set uses given function f to mock the Storage.GetLifeline method
func (mmGetLifeline *mStorageMockGetLifeline) Set(f func(objRef []byte, fromIndex *string, pulseNumberLt *int, pulseNumberGt *int, timestampLte *int, timestampGte *int, limit int, offset int, sort string) (ra1 []models.Record, i1 int, err error)) *StorageMock {
	if mmGetLifeline.defaultExpectation != nil {
		mmGetLifeline.mock.t.Fatalf("Default expectation is already set for the Storage.GetLifeline method")
	}

	if len(mmGetLifeline.expectations) > 0 {
		mmGetLifeline.mock.t.Fatalf("Some expectations are already set for the Storage.GetLifeline method")
	}

	mmGetLifeline.mock.funcGetLifeline = f
	return mmGetLifeline.mock
}

// When sets expectation for the Storage.GetLifeline which will trigger the result defined by the following
// Then helper
func (mmGetLifeline *mStorageMockGetLifeline) When(objRef []byte, fromIndex *string, pulseNumberLt *int, pulseNumberGt *int, timestampLte *int, timestampGte *int, limit int, offset int, sort string) *StorageMockGetLifelineExpectation {
	if mmGetLifeline.mock.funcGetLifeline != nil {
		mmGetLifeline.mock.t.Fatalf("StorageMock.GetLifeline mock is already set by Set")
	}

	expectation := &StorageMockGetLifelineExpectation{
		mock:   mmGetLifeline.mock,
		params: &StorageMockGetLifelineParams{objRef, fromIndex, pulseNumberLt, pulseNumberGt, timestampLte, timestampGte, limit, offset, sort},
	}
	mmGetLifeline.expectations = append(mmGetLifeline.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetLifeline return parameters for the expectation previously defined by the When method
func (e *StorageMockGetLifelineExpectation) Then(ra1 []models.Record, i1 int, err error) *StorageMock {
	e.results = &StorageMockGetLifelineResults{ra1, i1, err}
	return e.mock
}

// GetLifeline implements interfaces.Storage
func (mmGetLifeline *StorageMock) GetLifeline(objRef []byte, fromIndex *string, pulseNumberLt *int, pulseNumberGt *int, timestampLte *int, timestampGte *int, limit int, offset int, sort string) (ra1 []models.Record, i1 int, err error) {
	mm_atomic.AddUint64(&mmGetLifeline.beforeGetLifelineCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLifeline.afterGetLifelineCounter, 1)

	if mmGetLifeline.inspectFuncGetLifeline != nil {
		mmGetLifeline.inspectFuncGetLifeline(objRef, fromIndex, pulseNumberLt, pulseNumberGt, timestampLte, timestampGte, limit, offset, sort)
	}

	mm_params := &StorageMockGetLifelineParams{objRef, fromIndex, pulseNumberLt, pulseNumberGt, timestampLte, timestampGte, limit, offset, sort}

	// Record call args
	mmGetLifeline.GetLifelineMock.mutex.Lock()
	mmGetLifeline.GetLifelineMock.callArgs = append(mmGetLifeline.GetLifelineMock.callArgs, mm_params)
	mmGetLifeline.GetLifelineMock.mutex.Unlock()

	for _, e := range mmGetLifeline.GetLifelineMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ra1, e.results.i1, e.results.err
		}
	}

	if mmGetLifeline.GetLifelineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLifeline.GetLifelineMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLifeline.GetLifelineMock.defaultExpectation.params
		mm_got := StorageMockGetLifelineParams{objRef, fromIndex, pulseNumberLt, pulseNumberGt, timestampLte, timestampGte, limit, offset, sort}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLifeline.t.Errorf("StorageMock.GetLifeline got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLifeline.GetLifelineMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLifeline.t.Fatal("No results are set for the StorageMock.GetLifeline")
		}
		return (*mm_results).ra1, (*mm_results).i1, (*mm_results).err
	}
	if mmGetLifeline.funcGetLifeline != nil {
		return mmGetLifeline.funcGetLifeline(objRef, fromIndex, pulseNumberLt, pulseNumberGt, timestampLte, timestampGte, limit, offset, sort)
	}
	mmGetLifeline.t.Fatalf("Unexpected call to StorageMock.GetLifeline. %v %v %v %v %v %v %v %v %v", objRef, fromIndex, pulseNumberLt, pulseNumberGt, timestampLte, timestampGte, limit, offset, sort)
	return
}

// GetLifelineAfterCounter returns a count of finished StorageMock.GetLifeline invocations
func (mmGetLifeline *StorageMock) GetLifelineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLifeline.afterGetLifelineCounter)
}

// GetLifelineBeforeCounter returns a count of StorageMock.GetLifeline invocations
func (mmGetLifeline *StorageMock) GetLifelineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLifeline.beforeGetLifelineCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetLifeline.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLifeline *mStorageMockGetLifeline) Calls() []*StorageMockGetLifelineParams {
	mmGetLifeline.mutex.RLock()

	argCopy := make([]*StorageMockGetLifelineParams, len(mmGetLifeline.callArgs))
	copy(argCopy, mmGetLifeline.callArgs)

	mmGetLifeline.mutex.RUnlock()

	return argCopy
}

// MinimockGetLifelineDone returns true if the count of the GetLifeline invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetLifelineDone() bool {
	for _, e := range m.GetLifelineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetLifelineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetLifelineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLifeline != nil && mm_atomic.LoadUint64(&m.afterGetLifelineCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetLifelineInspect logs each unmet expectation
func (m *StorageMock) MinimockGetLifelineInspect() {
	for _, e := range m.GetLifelineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetLifeline with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetLifelineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetLifelineCounter) < 1 {
		if m.GetLifelineMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetLifeline")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetLifeline with params: %#v", *m.GetLifelineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLifeline != nil && mm_atomic.LoadUint64(&m.afterGetLifelineCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetLifeline")
	}
}

type mStorageMockGetPulse struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetPulseExpectation
	expectations       []*StorageMockGetPulseExpectation

	callArgs []*StorageMockGetPulseParams
	mutex    sync.RWMutex
}

// StorageMockGetPulseExpectation specifies expectation struct of the Storage.GetPulse
type StorageMockGetPulseExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetPulseParams
	results *StorageMockGetPulseResults
	Counter uint64
}

// StorageMockGetPulseParams contains parameters of the Storage.GetPulse
type StorageMockGetPulseParams struct {
	pulseNumber int
}

// StorageMockGetPulseResults contains results of the Storage.GetPulse
type StorageMockGetPulseResults struct {
	p1  models.Pulse
	i1  int64
	i2  int64
	err error
}

// Expect sets up expected params for Storage.GetPulse
func (mmGetPulse *mStorageMockGetPulse) Expect(pulseNumber int) *mStorageMockGetPulse {
	if mmGetPulse.mock.funcGetPulse != nil {
		mmGetPulse.mock.t.Fatalf("StorageMock.GetPulse mock is already set by Set")
	}

	if mmGetPulse.defaultExpectation == nil {
		mmGetPulse.defaultExpectation = &StorageMockGetPulseExpectation{}
	}

	mmGetPulse.defaultExpectation.params = &StorageMockGetPulseParams{pulseNumber}
	for _, e := range mmGetPulse.expectations {
		if minimock.Equal(e.params, mmGetPulse.defaultExpectation.params) {
			mmGetPulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPulse.defaultExpectation.params)
		}
	}

	return mmGetPulse
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetPulse
func (mmGetPulse *mStorageMockGetPulse) Inspect(f func(pulseNumber int)) *mStorageMockGetPulse {
	if mmGetPulse.mock.inspectFuncGetPulse != nil {
		mmGetPulse.mock.t.Fatalf("Inspect function is already set for StorageMock.GetPulse")
	}

	mmGetPulse.mock.inspectFuncGetPulse = f

	return mmGetPulse
}

// Return sets up results that will be returned by Storage.GetPulse
func (mmGetPulse *mStorageMockGetPulse) Return(p1 models.Pulse, i1 int64, i2 int64, err error) *StorageMock {
	if mmGetPulse.mock.funcGetPulse != nil {
		mmGetPulse.mock.t.Fatalf("StorageMock.GetPulse mock is already set by Set")
	}

	if mmGetPulse.defaultExpectation == nil {
		mmGetPulse.defaultExpectation = &StorageMockGetPulseExpectation{mock: mmGetPulse.mock}
	}
	mmGetPulse.defaultExpectation.results = &StorageMockGetPulseResults{p1, i1, i2, err}
	return mmGetPulse.mock
}

//Set uses given function f to mock the Storage.GetPulse method
func (mmGetPulse *mStorageMockGetPulse) Set(f func(pulseNumber int) (p1 models.Pulse, i1 int64, i2 int64, err error)) *StorageMock {
	if mmGetPulse.defaultExpectation != nil {
		mmGetPulse.mock.t.Fatalf("Default expectation is already set for the Storage.GetPulse method")
	}

	if len(mmGetPulse.expectations) > 0 {
		mmGetPulse.mock.t.Fatalf("Some expectations are already set for the Storage.GetPulse method")
	}

	mmGetPulse.mock.funcGetPulse = f
	return mmGetPulse.mock
}

// When sets expectation for the Storage.GetPulse which will trigger the result defined by the following
// Then helper
func (mmGetPulse *mStorageMockGetPulse) When(pulseNumber int) *StorageMockGetPulseExpectation {
	if mmGetPulse.mock.funcGetPulse != nil {
		mmGetPulse.mock.t.Fatalf("StorageMock.GetPulse mock is already set by Set")
	}

	expectation := &StorageMockGetPulseExpectation{
		mock:   mmGetPulse.mock,
		params: &StorageMockGetPulseParams{pulseNumber},
	}
	mmGetPulse.expectations = append(mmGetPulse.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetPulse return parameters for the expectation previously defined by the When method
func (e *StorageMockGetPulseExpectation) Then(p1 models.Pulse, i1 int64, i2 int64, err error) *StorageMock {
	e.results = &StorageMockGetPulseResults{p1, i1, i2, err}
	return e.mock
}

// GetPulse implements interfaces.Storage
func (mmGetPulse *StorageMock) GetPulse(pulseNumber int) (p1 models.Pulse, i1 int64, i2 int64, err error) {
	mm_atomic.AddUint64(&mmGetPulse.beforeGetPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPulse.afterGetPulseCounter, 1)

	if mmGetPulse.inspectFuncGetPulse != nil {
		mmGetPulse.inspectFuncGetPulse(pulseNumber)
	}

	mm_params := &StorageMockGetPulseParams{pulseNumber}

	// Record call args
	mmGetPulse.GetPulseMock.mutex.Lock()
	mmGetPulse.GetPulseMock.callArgs = append(mmGetPulse.GetPulseMock.callArgs, mm_params)
	mmGetPulse.GetPulseMock.mutex.Unlock()

	for _, e := range mmGetPulse.GetPulseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.i1, e.results.i2, e.results.err
		}
	}

	if mmGetPulse.GetPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPulse.GetPulseMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPulse.GetPulseMock.defaultExpectation.params
		mm_got := StorageMockGetPulseParams{pulseNumber}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPulse.t.Errorf("StorageMock.GetPulse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPulse.GetPulseMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPulse.t.Fatal("No results are set for the StorageMock.GetPulse")
		}
		return (*mm_results).p1, (*mm_results).i1, (*mm_results).i2, (*mm_results).err
	}
	if mmGetPulse.funcGetPulse != nil {
		return mmGetPulse.funcGetPulse(pulseNumber)
	}
	mmGetPulse.t.Fatalf("Unexpected call to StorageMock.GetPulse. %v", pulseNumber)
	return
}

// GetPulseAfterCounter returns a count of finished StorageMock.GetPulse invocations
func (mmGetPulse *StorageMock) GetPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPulse.afterGetPulseCounter)
}

// GetPulseBeforeCounter returns a count of StorageMock.GetPulse invocations
func (mmGetPulse *StorageMock) GetPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPulse.beforeGetPulseCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetPulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPulse *mStorageMockGetPulse) Calls() []*StorageMockGetPulseParams {
	mmGetPulse.mutex.RLock()

	argCopy := make([]*StorageMockGetPulseParams, len(mmGetPulse.callArgs))
	copy(argCopy, mmGetPulse.callArgs)

	mmGetPulse.mutex.RUnlock()

	return argCopy
}

// MinimockGetPulseDone returns true if the count of the GetPulse invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetPulseDone() bool {
	for _, e := range m.GetPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPulse != nil && mm_atomic.LoadUint64(&m.afterGetPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPulseInspect logs each unmet expectation
func (m *StorageMock) MinimockGetPulseInspect() {
	for _, e := range m.GetPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetPulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPulseCounter) < 1 {
		if m.GetPulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetPulse")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetPulse with params: %#v", *m.GetPulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPulse != nil && mm_atomic.LoadUint64(&m.afterGetPulseCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetPulse")
	}
}

type mStorageMockGetPulses struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetPulsesExpectation
	expectations       []*StorageMockGetPulsesExpectation

	callArgs []*StorageMockGetPulsesParams
	mutex    sync.RWMutex
}

// StorageMockGetPulsesExpectation specifies expectation struct of the Storage.GetPulses
type StorageMockGetPulsesExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetPulsesParams
	results *StorageMockGetPulsesResults
	Counter uint64
}

// StorageMockGetPulsesParams contains parameters of the Storage.GetPulses
type StorageMockGetPulsesParams struct {
	fromPulse    *int64
	timestampLte *int
	timestampGte *int
	limit        int
	offset       int
}

// StorageMockGetPulsesResults contains results of the Storage.GetPulses
type StorageMockGetPulsesResults struct {
	pa1 []models.Pulse
	i1  int
	err error
}

// Expect sets up expected params for Storage.GetPulses
func (mmGetPulses *mStorageMockGetPulses) Expect(fromPulse *int64, timestampLte *int, timestampGte *int, limit int, offset int) *mStorageMockGetPulses {
	if mmGetPulses.mock.funcGetPulses != nil {
		mmGetPulses.mock.t.Fatalf("StorageMock.GetPulses mock is already set by Set")
	}

	if mmGetPulses.defaultExpectation == nil {
		mmGetPulses.defaultExpectation = &StorageMockGetPulsesExpectation{}
	}

	mmGetPulses.defaultExpectation.params = &StorageMockGetPulsesParams{fromPulse, timestampLte, timestampGte, limit, offset}
	for _, e := range mmGetPulses.expectations {
		if minimock.Equal(e.params, mmGetPulses.defaultExpectation.params) {
			mmGetPulses.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPulses.defaultExpectation.params)
		}
	}

	return mmGetPulses
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetPulses
func (mmGetPulses *mStorageMockGetPulses) Inspect(f func(fromPulse *int64, timestampLte *int, timestampGte *int, limit int, offset int)) *mStorageMockGetPulses {
	if mmGetPulses.mock.inspectFuncGetPulses != nil {
		mmGetPulses.mock.t.Fatalf("Inspect function is already set for StorageMock.GetPulses")
	}

	mmGetPulses.mock.inspectFuncGetPulses = f

	return mmGetPulses
}

// Return sets up results that will be returned by Storage.GetPulses
func (mmGetPulses *mStorageMockGetPulses) Return(pa1 []models.Pulse, i1 int, err error) *StorageMock {
	if mmGetPulses.mock.funcGetPulses != nil {
		mmGetPulses.mock.t.Fatalf("StorageMock.GetPulses mock is already set by Set")
	}

	if mmGetPulses.defaultExpectation == nil {
		mmGetPulses.defaultExpectation = &StorageMockGetPulsesExpectation{mock: mmGetPulses.mock}
	}
	mmGetPulses.defaultExpectation.results = &StorageMockGetPulsesResults{pa1, i1, err}
	return mmGetPulses.mock
}

//Set uses given function f to mock the Storage.GetPulses method
func (mmGetPulses *mStorageMockGetPulses) Set(f func(fromPulse *int64, timestampLte *int, timestampGte *int, limit int, offset int) (pa1 []models.Pulse, i1 int, err error)) *StorageMock {
	if mmGetPulses.defaultExpectation != nil {
		mmGetPulses.mock.t.Fatalf("Default expectation is already set for the Storage.GetPulses method")
	}

	if len(mmGetPulses.expectations) > 0 {
		mmGetPulses.mock.t.Fatalf("Some expectations are already set for the Storage.GetPulses method")
	}

	mmGetPulses.mock.funcGetPulses = f
	return mmGetPulses.mock
}

// When sets expectation for the Storage.GetPulses which will trigger the result defined by the following
// Then helper
func (mmGetPulses *mStorageMockGetPulses) When(fromPulse *int64, timestampLte *int, timestampGte *int, limit int, offset int) *StorageMockGetPulsesExpectation {
	if mmGetPulses.mock.funcGetPulses != nil {
		mmGetPulses.mock.t.Fatalf("StorageMock.GetPulses mock is already set by Set")
	}

	expectation := &StorageMockGetPulsesExpectation{
		mock:   mmGetPulses.mock,
		params: &StorageMockGetPulsesParams{fromPulse, timestampLte, timestampGte, limit, offset},
	}
	mmGetPulses.expectations = append(mmGetPulses.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetPulses return parameters for the expectation previously defined by the When method
func (e *StorageMockGetPulsesExpectation) Then(pa1 []models.Pulse, i1 int, err error) *StorageMock {
	e.results = &StorageMockGetPulsesResults{pa1, i1, err}
	return e.mock
}

// GetPulses implements interfaces.Storage
func (mmGetPulses *StorageMock) GetPulses(fromPulse *int64, timestampLte *int, timestampGte *int, limit int, offset int) (pa1 []models.Pulse, i1 int, err error) {
	mm_atomic.AddUint64(&mmGetPulses.beforeGetPulsesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPulses.afterGetPulsesCounter, 1)

	if mmGetPulses.inspectFuncGetPulses != nil {
		mmGetPulses.inspectFuncGetPulses(fromPulse, timestampLte, timestampGte, limit, offset)
	}

	mm_params := &StorageMockGetPulsesParams{fromPulse, timestampLte, timestampGte, limit, offset}

	// Record call args
	mmGetPulses.GetPulsesMock.mutex.Lock()
	mmGetPulses.GetPulsesMock.callArgs = append(mmGetPulses.GetPulsesMock.callArgs, mm_params)
	mmGetPulses.GetPulsesMock.mutex.Unlock()

	for _, e := range mmGetPulses.GetPulsesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.i1, e.results.err
		}
	}

	if mmGetPulses.GetPulsesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPulses.GetPulsesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPulses.GetPulsesMock.defaultExpectation.params
		mm_got := StorageMockGetPulsesParams{fromPulse, timestampLte, timestampGte, limit, offset}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPulses.t.Errorf("StorageMock.GetPulses got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPulses.GetPulsesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPulses.t.Fatal("No results are set for the StorageMock.GetPulses")
		}
		return (*mm_results).pa1, (*mm_results).i1, (*mm_results).err
	}
	if mmGetPulses.funcGetPulses != nil {
		return mmGetPulses.funcGetPulses(fromPulse, timestampLte, timestampGte, limit, offset)
	}
	mmGetPulses.t.Fatalf("Unexpected call to StorageMock.GetPulses. %v %v %v %v %v", fromPulse, timestampLte, timestampGte, limit, offset)
	return
}

// GetPulsesAfterCounter returns a count of finished StorageMock.GetPulses invocations
func (mmGetPulses *StorageMock) GetPulsesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPulses.afterGetPulsesCounter)
}

// GetPulsesBeforeCounter returns a count of StorageMock.GetPulses invocations
func (mmGetPulses *StorageMock) GetPulsesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPulses.beforeGetPulsesCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetPulses.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPulses *mStorageMockGetPulses) Calls() []*StorageMockGetPulsesParams {
	mmGetPulses.mutex.RLock()

	argCopy := make([]*StorageMockGetPulsesParams, len(mmGetPulses.callArgs))
	copy(argCopy, mmGetPulses.callArgs)

	mmGetPulses.mutex.RUnlock()

	return argCopy
}

// MinimockGetPulsesDone returns true if the count of the GetPulses invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetPulsesDone() bool {
	for _, e := range m.GetPulsesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPulsesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPulsesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPulses != nil && mm_atomic.LoadUint64(&m.afterGetPulsesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPulsesInspect logs each unmet expectation
func (m *StorageMock) MinimockGetPulsesInspect() {
	for _, e := range m.GetPulsesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetPulses with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPulsesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPulsesCounter) < 1 {
		if m.GetPulsesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetPulses")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetPulses with params: %#v", *m.GetPulsesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPulses != nil && mm_atomic.LoadUint64(&m.afterGetPulsesCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetPulses")
	}
}

type mStorageMockGetRecord struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetRecordExpectation
	expectations       []*StorageMockGetRecordExpectation

	callArgs []*StorageMockGetRecordParams
	mutex    sync.RWMutex
}

// StorageMockGetRecordExpectation specifies expectation struct of the Storage.GetRecord
type StorageMockGetRecordExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetRecordParams
	results *StorageMockGetRecordResults
	Counter uint64
}

// StorageMockGetRecordParams contains parameters of the Storage.GetRecord
type StorageMockGetRecordParams struct {
	ref models.Reference
}

// StorageMockGetRecordResults contains results of the Storage.GetRecord
type StorageMockGetRecordResults struct {
	r1  models.Record
	err error
}

// Expect sets up expected params for Storage.GetRecord
func (mmGetRecord *mStorageMockGetRecord) Expect(ref models.Reference) *mStorageMockGetRecord {
	if mmGetRecord.mock.funcGetRecord != nil {
		mmGetRecord.mock.t.Fatalf("StorageMock.GetRecord mock is already set by Set")
	}

	if mmGetRecord.defaultExpectation == nil {
		mmGetRecord.defaultExpectation = &StorageMockGetRecordExpectation{}
	}

	mmGetRecord.defaultExpectation.params = &StorageMockGetRecordParams{ref}
	for _, e := range mmGetRecord.expectations {
		if minimock.Equal(e.params, mmGetRecord.defaultExpectation.params) {
			mmGetRecord.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRecord.defaultExpectation.params)
		}
	}

	return mmGetRecord
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetRecord
func (mmGetRecord *mStorageMockGetRecord) Inspect(f func(ref models.Reference)) *mStorageMockGetRecord {
	if mmGetRecord.mock.inspectFuncGetRecord != nil {
		mmGetRecord.mock.t.Fatalf("Inspect function is already set for StorageMock.GetRecord")
	}

	mmGetRecord.mock.inspectFuncGetRecord = f

	return mmGetRecord
}

// Return sets up results that will be returned by Storage.GetRecord
func (mmGetRecord *mStorageMockGetRecord) Return(r1 models.Record, err error) *StorageMock {
	if mmGetRecord.mock.funcGetRecord != nil {
		mmGetRecord.mock.t.Fatalf("StorageMock.GetRecord mock is already set by Set")
	}

	if mmGetRecord.defaultExpectation == nil {
		mmGetRecord.defaultExpectation = &StorageMockGetRecordExpectation{mock: mmGetRecord.mock}
	}
	mmGetRecord.defaultExpectation.results = &StorageMockGetRecordResults{r1, err}
	return mmGetRecord.mock
}

//Set uses given function f to mock the Storage.GetRecord method
func (mmGetRecord *mStorageMockGetRecord) Set(f func(ref models.Reference) (r1 models.Record, err error)) *StorageMock {
	if mmGetRecord.defaultExpectation != nil {
		mmGetRecord.mock.t.Fatalf("Default expectation is already set for the Storage.GetRecord method")
	}

	if len(mmGetRecord.expectations) > 0 {
		mmGetRecord.mock.t.Fatalf("Some expectations are already set for the Storage.GetRecord method")
	}

	mmGetRecord.mock.funcGetRecord = f
	return mmGetRecord.mock
}

// When sets expectation for the Storage.GetRecord which will trigger the result defined by the following
// Then helper
func (mmGetRecord *mStorageMockGetRecord) When(ref models.Reference) *StorageMockGetRecordExpectation {
	if mmGetRecord.mock.funcGetRecord != nil {
		mmGetRecord.mock.t.Fatalf("StorageMock.GetRecord mock is already set by Set")
	}

	expectation := &StorageMockGetRecordExpectation{
		mock:   mmGetRecord.mock,
		params: &StorageMockGetRecordParams{ref},
	}
	mmGetRecord.expectations = append(mmGetRecord.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetRecord return parameters for the expectation previously defined by the When method
func (e *StorageMockGetRecordExpectation) Then(r1 models.Record, err error) *StorageMock {
	e.results = &StorageMockGetRecordResults{r1, err}
	return e.mock
}

// GetRecord implements interfaces.Storage
func (mmGetRecord *StorageMock) GetRecord(ref models.Reference) (r1 models.Record, err error) {
	mm_atomic.AddUint64(&mmGetRecord.beforeGetRecordCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRecord.afterGetRecordCounter, 1)

	if mmGetRecord.inspectFuncGetRecord != nil {
		mmGetRecord.inspectFuncGetRecord(ref)
	}

	mm_params := &StorageMockGetRecordParams{ref}

	// Record call args
	mmGetRecord.GetRecordMock.mutex.Lock()
	mmGetRecord.GetRecordMock.callArgs = append(mmGetRecord.GetRecordMock.callArgs, mm_params)
	mmGetRecord.GetRecordMock.mutex.Unlock()

	for _, e := range mmGetRecord.GetRecordMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmGetRecord.GetRecordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRecord.GetRecordMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRecord.GetRecordMock.defaultExpectation.params
		mm_got := StorageMockGetRecordParams{ref}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRecord.t.Errorf("StorageMock.GetRecord got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRecord.GetRecordMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRecord.t.Fatal("No results are set for the StorageMock.GetRecord")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmGetRecord.funcGetRecord != nil {
		return mmGetRecord.funcGetRecord(ref)
	}
	mmGetRecord.t.Fatalf("Unexpected call to StorageMock.GetRecord. %v", ref)
	return
}

// GetRecordAfterCounter returns a count of finished StorageMock.GetRecord invocations
func (mmGetRecord *StorageMock) GetRecordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRecord.afterGetRecordCounter)
}

// GetRecordBeforeCounter returns a count of StorageMock.GetRecord invocations
func (mmGetRecord *StorageMock) GetRecordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRecord.beforeGetRecordCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetRecord.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRecord *mStorageMockGetRecord) Calls() []*StorageMockGetRecordParams {
	mmGetRecord.mutex.RLock()

	argCopy := make([]*StorageMockGetRecordParams, len(mmGetRecord.callArgs))
	copy(argCopy, mmGetRecord.callArgs)

	mmGetRecord.mutex.RUnlock()

	return argCopy
}

// MinimockGetRecordDone returns true if the count of the GetRecord invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetRecordDone() bool {
	for _, e := range m.GetRecordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRecordMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRecordCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRecord != nil && mm_atomic.LoadUint64(&m.afterGetRecordCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRecordInspect logs each unmet expectation
func (m *StorageMock) MinimockGetRecordInspect() {
	for _, e := range m.GetRecordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetRecord with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRecordMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRecordCounter) < 1 {
		if m.GetRecordMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetRecord")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetRecord with params: %#v", *m.GetRecordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRecord != nil && mm_atomic.LoadUint64(&m.afterGetRecordCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetRecord")
	}
}

type mStorageMockGetRecordsByJetDrop struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetRecordsByJetDropExpectation
	expectations       []*StorageMockGetRecordsByJetDropExpectation

	callArgs []*StorageMockGetRecordsByJetDropParams
	mutex    sync.RWMutex
}

// StorageMockGetRecordsByJetDropExpectation specifies expectation struct of the Storage.GetRecordsByJetDrop
type StorageMockGetRecordsByJetDropExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetRecordsByJetDropParams
	results *StorageMockGetRecordsByJetDropResults
	Counter uint64
}

// StorageMockGetRecordsByJetDropParams contains parameters of the Storage.GetRecordsByJetDrop
type StorageMockGetRecordsByJetDropParams struct {
	jetDropID  models.JetDropID
	fromIndex  *string
	recordType *string
	limit      int
	offset     int
}

// StorageMockGetRecordsByJetDropResults contains results of the Storage.GetRecordsByJetDrop
type StorageMockGetRecordsByJetDropResults struct {
	ra1 []models.Record
	i1  int
	err error
}

// Expect sets up expected params for Storage.GetRecordsByJetDrop
func (mmGetRecordsByJetDrop *mStorageMockGetRecordsByJetDrop) Expect(jetDropID models.JetDropID, fromIndex *string, recordType *string, limit int, offset int) *mStorageMockGetRecordsByJetDrop {
	if mmGetRecordsByJetDrop.mock.funcGetRecordsByJetDrop != nil {
		mmGetRecordsByJetDrop.mock.t.Fatalf("StorageMock.GetRecordsByJetDrop mock is already set by Set")
	}

	if mmGetRecordsByJetDrop.defaultExpectation == nil {
		mmGetRecordsByJetDrop.defaultExpectation = &StorageMockGetRecordsByJetDropExpectation{}
	}

	mmGetRecordsByJetDrop.defaultExpectation.params = &StorageMockGetRecordsByJetDropParams{jetDropID, fromIndex, recordType, limit, offset}
	for _, e := range mmGetRecordsByJetDrop.expectations {
		if minimock.Equal(e.params, mmGetRecordsByJetDrop.defaultExpectation.params) {
			mmGetRecordsByJetDrop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRecordsByJetDrop.defaultExpectation.params)
		}
	}

	return mmGetRecordsByJetDrop
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetRecordsByJetDrop
func (mmGetRecordsByJetDrop *mStorageMockGetRecordsByJetDrop) Inspect(f func(jetDropID models.JetDropID, fromIndex *string, recordType *string, limit int, offset int)) *mStorageMockGetRecordsByJetDrop {
	if mmGetRecordsByJetDrop.mock.inspectFuncGetRecordsByJetDrop != nil {
		mmGetRecordsByJetDrop.mock.t.Fatalf("Inspect function is already set for StorageMock.GetRecordsByJetDrop")
	}

	mmGetRecordsByJetDrop.mock.inspectFuncGetRecordsByJetDrop = f

	return mmGetRecordsByJetDrop
}

// Return sets up results that will be returned by Storage.GetRecordsByJetDrop
func (mmGetRecordsByJetDrop *mStorageMockGetRecordsByJetDrop) Return(ra1 []models.Record, i1 int, err error) *StorageMock {
	if mmGetRecordsByJetDrop.mock.funcGetRecordsByJetDrop != nil {
		mmGetRecordsByJetDrop.mock.t.Fatalf("StorageMock.GetRecordsByJetDrop mock is already set by Set")
	}

	if mmGetRecordsByJetDrop.defaultExpectation == nil {
		mmGetRecordsByJetDrop.defaultExpectation = &StorageMockGetRecordsByJetDropExpectation{mock: mmGetRecordsByJetDrop.mock}
	}
	mmGetRecordsByJetDrop.defaultExpectation.results = &StorageMockGetRecordsByJetDropResults{ra1, i1, err}
	return mmGetRecordsByJetDrop.mock
}

//Set uses given function f to mock the Storage.GetRecordsByJetDrop method
func (mmGetRecordsByJetDrop *mStorageMockGetRecordsByJetDrop) Set(f func(jetDropID models.JetDropID, fromIndex *string, recordType *string, limit int, offset int) (ra1 []models.Record, i1 int, err error)) *StorageMock {
	if mmGetRecordsByJetDrop.defaultExpectation != nil {
		mmGetRecordsByJetDrop.mock.t.Fatalf("Default expectation is already set for the Storage.GetRecordsByJetDrop method")
	}

	if len(mmGetRecordsByJetDrop.expectations) > 0 {
		mmGetRecordsByJetDrop.mock.t.Fatalf("Some expectations are already set for the Storage.GetRecordsByJetDrop method")
	}

	mmGetRecordsByJetDrop.mock.funcGetRecordsByJetDrop = f
	return mmGetRecordsByJetDrop.mock
}

// When sets expectation for the Storage.GetRecordsByJetDrop which will trigger the result defined by the following
// Then helper
func (mmGetRecordsByJetDrop *mStorageMockGetRecordsByJetDrop) When(jetDropID models.JetDropID, fromIndex *string, recordType *string, limit int, offset int) *StorageMockGetRecordsByJetDropExpectation {
	if mmGetRecordsByJetDrop.mock.funcGetRecordsByJetDrop != nil {
		mmGetRecordsByJetDrop.mock.t.Fatalf("StorageMock.GetRecordsByJetDrop mock is already set by Set")
	}

	expectation := &StorageMockGetRecordsByJetDropExpectation{
		mock:   mmGetRecordsByJetDrop.mock,
		params: &StorageMockGetRecordsByJetDropParams{jetDropID, fromIndex, recordType, limit, offset},
	}
	mmGetRecordsByJetDrop.expectations = append(mmGetRecordsByJetDrop.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetRecordsByJetDrop return parameters for the expectation previously defined by the When method
func (e *StorageMockGetRecordsByJetDropExpectation) Then(ra1 []models.Record, i1 int, err error) *StorageMock {
	e.results = &StorageMockGetRecordsByJetDropResults{ra1, i1, err}
	return e.mock
}

// GetRecordsByJetDrop implements interfaces.Storage
func (mmGetRecordsByJetDrop *StorageMock) GetRecordsByJetDrop(jetDropID models.JetDropID, fromIndex *string, recordType *string, limit int, offset int) (ra1 []models.Record, i1 int, err error) {
	mm_atomic.AddUint64(&mmGetRecordsByJetDrop.beforeGetRecordsByJetDropCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRecordsByJetDrop.afterGetRecordsByJetDropCounter, 1)

	if mmGetRecordsByJetDrop.inspectFuncGetRecordsByJetDrop != nil {
		mmGetRecordsByJetDrop.inspectFuncGetRecordsByJetDrop(jetDropID, fromIndex, recordType, limit, offset)
	}

	mm_params := &StorageMockGetRecordsByJetDropParams{jetDropID, fromIndex, recordType, limit, offset}

	// Record call args
	mmGetRecordsByJetDrop.GetRecordsByJetDropMock.mutex.Lock()
	mmGetRecordsByJetDrop.GetRecordsByJetDropMock.callArgs = append(mmGetRecordsByJetDrop.GetRecordsByJetDropMock.callArgs, mm_params)
	mmGetRecordsByJetDrop.GetRecordsByJetDropMock.mutex.Unlock()

	for _, e := range mmGetRecordsByJetDrop.GetRecordsByJetDropMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ra1, e.results.i1, e.results.err
		}
	}

	if mmGetRecordsByJetDrop.GetRecordsByJetDropMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRecordsByJetDrop.GetRecordsByJetDropMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRecordsByJetDrop.GetRecordsByJetDropMock.defaultExpectation.params
		mm_got := StorageMockGetRecordsByJetDropParams{jetDropID, fromIndex, recordType, limit, offset}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRecordsByJetDrop.t.Errorf("StorageMock.GetRecordsByJetDrop got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRecordsByJetDrop.GetRecordsByJetDropMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRecordsByJetDrop.t.Fatal("No results are set for the StorageMock.GetRecordsByJetDrop")
		}
		return (*mm_results).ra1, (*mm_results).i1, (*mm_results).err
	}
	if mmGetRecordsByJetDrop.funcGetRecordsByJetDrop != nil {
		return mmGetRecordsByJetDrop.funcGetRecordsByJetDrop(jetDropID, fromIndex, recordType, limit, offset)
	}
	mmGetRecordsByJetDrop.t.Fatalf("Unexpected call to StorageMock.GetRecordsByJetDrop. %v %v %v %v %v", jetDropID, fromIndex, recordType, limit, offset)
	return
}

// GetRecordsByJetDropAfterCounter returns a count of finished StorageMock.GetRecordsByJetDrop invocations
func (mmGetRecordsByJetDrop *StorageMock) GetRecordsByJetDropAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRecordsByJetDrop.afterGetRecordsByJetDropCounter)
}

// GetRecordsByJetDropBeforeCounter returns a count of StorageMock.GetRecordsByJetDrop invocations
func (mmGetRecordsByJetDrop *StorageMock) GetRecordsByJetDropBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRecordsByJetDrop.beforeGetRecordsByJetDropCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetRecordsByJetDrop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRecordsByJetDrop *mStorageMockGetRecordsByJetDrop) Calls() []*StorageMockGetRecordsByJetDropParams {
	mmGetRecordsByJetDrop.mutex.RLock()

	argCopy := make([]*StorageMockGetRecordsByJetDropParams, len(mmGetRecordsByJetDrop.callArgs))
	copy(argCopy, mmGetRecordsByJetDrop.callArgs)

	mmGetRecordsByJetDrop.mutex.RUnlock()

	return argCopy
}

// MinimockGetRecordsByJetDropDone returns true if the count of the GetRecordsByJetDrop invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetRecordsByJetDropDone() bool {
	for _, e := range m.GetRecordsByJetDropMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRecordsByJetDropMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRecordsByJetDropCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRecordsByJetDrop != nil && mm_atomic.LoadUint64(&m.afterGetRecordsByJetDropCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRecordsByJetDropInspect logs each unmet expectation
func (m *StorageMock) MinimockGetRecordsByJetDropInspect() {
	for _, e := range m.GetRecordsByJetDropMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetRecordsByJetDrop with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRecordsByJetDropMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRecordsByJetDropCounter) < 1 {
		if m.GetRecordsByJetDropMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetRecordsByJetDrop")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetRecordsByJetDrop with params: %#v", *m.GetRecordsByJetDropMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRecordsByJetDrop != nil && mm_atomic.LoadUint64(&m.afterGetRecordsByJetDropCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetRecordsByJetDrop")
	}
}

type mStorageMockSaveJetDropData struct {
	mock               *StorageMock
	defaultExpectation *StorageMockSaveJetDropDataExpectation
	expectations       []*StorageMockSaveJetDropDataExpectation

	callArgs []*StorageMockSaveJetDropDataParams
	mutex    sync.RWMutex
}

// StorageMockSaveJetDropDataExpectation specifies expectation struct of the Storage.SaveJetDropData
type StorageMockSaveJetDropDataExpectation struct {
	mock    *StorageMock
	params  *StorageMockSaveJetDropDataParams
	results *StorageMockSaveJetDropDataResults
	Counter uint64
}

// StorageMockSaveJetDropDataParams contains parameters of the Storage.SaveJetDropData
type StorageMockSaveJetDropDataParams struct {
	jetDrop models.JetDrop
	records []models.Record
}

// StorageMockSaveJetDropDataResults contains results of the Storage.SaveJetDropData
type StorageMockSaveJetDropDataResults struct {
	err error
}

// Expect sets up expected params for Storage.SaveJetDropData
func (mmSaveJetDropData *mStorageMockSaveJetDropData) Expect(jetDrop models.JetDrop, records []models.Record) *mStorageMockSaveJetDropData {
	if mmSaveJetDropData.mock.funcSaveJetDropData != nil {
		mmSaveJetDropData.mock.t.Fatalf("StorageMock.SaveJetDropData mock is already set by Set")
	}

	if mmSaveJetDropData.defaultExpectation == nil {
		mmSaveJetDropData.defaultExpectation = &StorageMockSaveJetDropDataExpectation{}
	}

	mmSaveJetDropData.defaultExpectation.params = &StorageMockSaveJetDropDataParams{jetDrop, records}
	for _, e := range mmSaveJetDropData.expectations {
		if minimock.Equal(e.params, mmSaveJetDropData.defaultExpectation.params) {
			mmSaveJetDropData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveJetDropData.defaultExpectation.params)
		}
	}

	return mmSaveJetDropData
}

// Inspect accepts an inspector function that has same arguments as the Storage.SaveJetDropData
func (mmSaveJetDropData *mStorageMockSaveJetDropData) Inspect(f func(jetDrop models.JetDrop, records []models.Record)) *mStorageMockSaveJetDropData {
	if mmSaveJetDropData.mock.inspectFuncSaveJetDropData != nil {
		mmSaveJetDropData.mock.t.Fatalf("Inspect function is already set for StorageMock.SaveJetDropData")
	}

	mmSaveJetDropData.mock.inspectFuncSaveJetDropData = f

	return mmSaveJetDropData
}

// Return sets up results that will be returned by Storage.SaveJetDropData
func (mmSaveJetDropData *mStorageMockSaveJetDropData) Return(err error) *StorageMock {
	if mmSaveJetDropData.mock.funcSaveJetDropData != nil {
		mmSaveJetDropData.mock.t.Fatalf("StorageMock.SaveJetDropData mock is already set by Set")
	}

	if mmSaveJetDropData.defaultExpectation == nil {
		mmSaveJetDropData.defaultExpectation = &StorageMockSaveJetDropDataExpectation{mock: mmSaveJetDropData.mock}
	}
	mmSaveJetDropData.defaultExpectation.results = &StorageMockSaveJetDropDataResults{err}
	return mmSaveJetDropData.mock
}

//Set uses given function f to mock the Storage.SaveJetDropData method
func (mmSaveJetDropData *mStorageMockSaveJetDropData) Set(f func(jetDrop models.JetDrop, records []models.Record) (err error)) *StorageMock {
	if mmSaveJetDropData.defaultExpectation != nil {
		mmSaveJetDropData.mock.t.Fatalf("Default expectation is already set for the Storage.SaveJetDropData method")
	}

	if len(mmSaveJetDropData.expectations) > 0 {
		mmSaveJetDropData.mock.t.Fatalf("Some expectations are already set for the Storage.SaveJetDropData method")
	}

	mmSaveJetDropData.mock.funcSaveJetDropData = f
	return mmSaveJetDropData.mock
}

// When sets expectation for the Storage.SaveJetDropData which will trigger the result defined by the following
// Then helper
func (mmSaveJetDropData *mStorageMockSaveJetDropData) When(jetDrop models.JetDrop, records []models.Record) *StorageMockSaveJetDropDataExpectation {
	if mmSaveJetDropData.mock.funcSaveJetDropData != nil {
		mmSaveJetDropData.mock.t.Fatalf("StorageMock.SaveJetDropData mock is already set by Set")
	}

	expectation := &StorageMockSaveJetDropDataExpectation{
		mock:   mmSaveJetDropData.mock,
		params: &StorageMockSaveJetDropDataParams{jetDrop, records},
	}
	mmSaveJetDropData.expectations = append(mmSaveJetDropData.expectations, expectation)
	return expectation
}

// Then sets up Storage.SaveJetDropData return parameters for the expectation previously defined by the When method
func (e *StorageMockSaveJetDropDataExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockSaveJetDropDataResults{err}
	return e.mock
}

// SaveJetDropData implements interfaces.Storage
func (mmSaveJetDropData *StorageMock) SaveJetDropData(jetDrop models.JetDrop, records []models.Record) (err error) {
	mm_atomic.AddUint64(&mmSaveJetDropData.beforeSaveJetDropDataCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveJetDropData.afterSaveJetDropDataCounter, 1)

	if mmSaveJetDropData.inspectFuncSaveJetDropData != nil {
		mmSaveJetDropData.inspectFuncSaveJetDropData(jetDrop, records)
	}

	mm_params := &StorageMockSaveJetDropDataParams{jetDrop, records}

	// Record call args
	mmSaveJetDropData.SaveJetDropDataMock.mutex.Lock()
	mmSaveJetDropData.SaveJetDropDataMock.callArgs = append(mmSaveJetDropData.SaveJetDropDataMock.callArgs, mm_params)
	mmSaveJetDropData.SaveJetDropDataMock.mutex.Unlock()

	for _, e := range mmSaveJetDropData.SaveJetDropDataMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveJetDropData.SaveJetDropDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveJetDropData.SaveJetDropDataMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveJetDropData.SaveJetDropDataMock.defaultExpectation.params
		mm_got := StorageMockSaveJetDropDataParams{jetDrop, records}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveJetDropData.t.Errorf("StorageMock.SaveJetDropData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveJetDropData.SaveJetDropDataMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveJetDropData.t.Fatal("No results are set for the StorageMock.SaveJetDropData")
		}
		return (*mm_results).err
	}
	if mmSaveJetDropData.funcSaveJetDropData != nil {
		return mmSaveJetDropData.funcSaveJetDropData(jetDrop, records)
	}
	mmSaveJetDropData.t.Fatalf("Unexpected call to StorageMock.SaveJetDropData. %v %v", jetDrop, records)
	return
}

// SaveJetDropDataAfterCounter returns a count of finished StorageMock.SaveJetDropData invocations
func (mmSaveJetDropData *StorageMock) SaveJetDropDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveJetDropData.afterSaveJetDropDataCounter)
}

// SaveJetDropDataBeforeCounter returns a count of StorageMock.SaveJetDropData invocations
func (mmSaveJetDropData *StorageMock) SaveJetDropDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveJetDropData.beforeSaveJetDropDataCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SaveJetDropData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveJetDropData *mStorageMockSaveJetDropData) Calls() []*StorageMockSaveJetDropDataParams {
	mmSaveJetDropData.mutex.RLock()

	argCopy := make([]*StorageMockSaveJetDropDataParams, len(mmSaveJetDropData.callArgs))
	copy(argCopy, mmSaveJetDropData.callArgs)

	mmSaveJetDropData.mutex.RUnlock()

	return argCopy
}

// MinimockSaveJetDropDataDone returns true if the count of the SaveJetDropData invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSaveJetDropDataDone() bool {
	for _, e := range m.SaveJetDropDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveJetDropDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveJetDropDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveJetDropData != nil && mm_atomic.LoadUint64(&m.afterSaveJetDropDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveJetDropDataInspect logs each unmet expectation
func (m *StorageMock) MinimockSaveJetDropDataInspect() {
	for _, e := range m.SaveJetDropDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SaveJetDropData with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveJetDropDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveJetDropDataCounter) < 1 {
		if m.SaveJetDropDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.SaveJetDropData")
		} else {
			m.t.Errorf("Expected call to StorageMock.SaveJetDropData with params: %#v", *m.SaveJetDropDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveJetDropData != nil && mm_atomic.LoadUint64(&m.afterSaveJetDropDataCounter) < 1 {
		m.t.Error("Expected call to StorageMock.SaveJetDropData")
	}
}

type mStorageMockSavePulse struct {
	mock               *StorageMock
	defaultExpectation *StorageMockSavePulseExpectation
	expectations       []*StorageMockSavePulseExpectation

	callArgs []*StorageMockSavePulseParams
	mutex    sync.RWMutex
}

// StorageMockSavePulseExpectation specifies expectation struct of the Storage.SavePulse
type StorageMockSavePulseExpectation struct {
	mock    *StorageMock
	params  *StorageMockSavePulseParams
	results *StorageMockSavePulseResults
	Counter uint64
}

// StorageMockSavePulseParams contains parameters of the Storage.SavePulse
type StorageMockSavePulseParams struct {
	pulse models.Pulse
}

// StorageMockSavePulseResults contains results of the Storage.SavePulse
type StorageMockSavePulseResults struct {
	err error
}

// Expect sets up expected params for Storage.SavePulse
func (mmSavePulse *mStorageMockSavePulse) Expect(pulse models.Pulse) *mStorageMockSavePulse {
	if mmSavePulse.mock.funcSavePulse != nil {
		mmSavePulse.mock.t.Fatalf("StorageMock.SavePulse mock is already set by Set")
	}

	if mmSavePulse.defaultExpectation == nil {
		mmSavePulse.defaultExpectation = &StorageMockSavePulseExpectation{}
	}

	mmSavePulse.defaultExpectation.params = &StorageMockSavePulseParams{pulse}
	for _, e := range mmSavePulse.expectations {
		if minimock.Equal(e.params, mmSavePulse.defaultExpectation.params) {
			mmSavePulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSavePulse.defaultExpectation.params)
		}
	}

	return mmSavePulse
}

// Inspect accepts an inspector function that has same arguments as the Storage.SavePulse
func (mmSavePulse *mStorageMockSavePulse) Inspect(f func(pulse models.Pulse)) *mStorageMockSavePulse {
	if mmSavePulse.mock.inspectFuncSavePulse != nil {
		mmSavePulse.mock.t.Fatalf("Inspect function is already set for StorageMock.SavePulse")
	}

	mmSavePulse.mock.inspectFuncSavePulse = f

	return mmSavePulse
}

// Return sets up results that will be returned by Storage.SavePulse
func (mmSavePulse *mStorageMockSavePulse) Return(err error) *StorageMock {
	if mmSavePulse.mock.funcSavePulse != nil {
		mmSavePulse.mock.t.Fatalf("StorageMock.SavePulse mock is already set by Set")
	}

	if mmSavePulse.defaultExpectation == nil {
		mmSavePulse.defaultExpectation = &StorageMockSavePulseExpectation{mock: mmSavePulse.mock}
	}
	mmSavePulse.defaultExpectation.results = &StorageMockSavePulseResults{err}
	return mmSavePulse.mock
}

//Set uses given function f to mock the Storage.SavePulse method
func (mmSavePulse *mStorageMockSavePulse) Set(f func(pulse models.Pulse) (err error)) *StorageMock {
	if mmSavePulse.defaultExpectation != nil {
		mmSavePulse.mock.t.Fatalf("Default expectation is already set for the Storage.SavePulse method")
	}

	if len(mmSavePulse.expectations) > 0 {
		mmSavePulse.mock.t.Fatalf("Some expectations are already set for the Storage.SavePulse method")
	}

	mmSavePulse.mock.funcSavePulse = f
	return mmSavePulse.mock
}

// When sets expectation for the Storage.SavePulse which will trigger the result defined by the following
// Then helper
func (mmSavePulse *mStorageMockSavePulse) When(pulse models.Pulse) *StorageMockSavePulseExpectation {
	if mmSavePulse.mock.funcSavePulse != nil {
		mmSavePulse.mock.t.Fatalf("StorageMock.SavePulse mock is already set by Set")
	}

	expectation := &StorageMockSavePulseExpectation{
		mock:   mmSavePulse.mock,
		params: &StorageMockSavePulseParams{pulse},
	}
	mmSavePulse.expectations = append(mmSavePulse.expectations, expectation)
	return expectation
}

// Then sets up Storage.SavePulse return parameters for the expectation previously defined by the When method
func (e *StorageMockSavePulseExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockSavePulseResults{err}
	return e.mock
}

// SavePulse implements interfaces.Storage
func (mmSavePulse *StorageMock) SavePulse(pulse models.Pulse) (err error) {
	mm_atomic.AddUint64(&mmSavePulse.beforeSavePulseCounter, 1)
	defer mm_atomic.AddUint64(&mmSavePulse.afterSavePulseCounter, 1)

	if mmSavePulse.inspectFuncSavePulse != nil {
		mmSavePulse.inspectFuncSavePulse(pulse)
	}

	mm_params := &StorageMockSavePulseParams{pulse}

	// Record call args
	mmSavePulse.SavePulseMock.mutex.Lock()
	mmSavePulse.SavePulseMock.callArgs = append(mmSavePulse.SavePulseMock.callArgs, mm_params)
	mmSavePulse.SavePulseMock.mutex.Unlock()

	for _, e := range mmSavePulse.SavePulseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSavePulse.SavePulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSavePulse.SavePulseMock.defaultExpectation.Counter, 1)
		mm_want := mmSavePulse.SavePulseMock.defaultExpectation.params
		mm_got := StorageMockSavePulseParams{pulse}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSavePulse.t.Errorf("StorageMock.SavePulse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSavePulse.SavePulseMock.defaultExpectation.results
		if mm_results == nil {
			mmSavePulse.t.Fatal("No results are set for the StorageMock.SavePulse")
		}
		return (*mm_results).err
	}
	if mmSavePulse.funcSavePulse != nil {
		return mmSavePulse.funcSavePulse(pulse)
	}
	mmSavePulse.t.Fatalf("Unexpected call to StorageMock.SavePulse. %v", pulse)
	return
}

// SavePulseAfterCounter returns a count of finished StorageMock.SavePulse invocations
func (mmSavePulse *StorageMock) SavePulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSavePulse.afterSavePulseCounter)
}

// SavePulseBeforeCounter returns a count of StorageMock.SavePulse invocations
func (mmSavePulse *StorageMock) SavePulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSavePulse.beforeSavePulseCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SavePulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSavePulse *mStorageMockSavePulse) Calls() []*StorageMockSavePulseParams {
	mmSavePulse.mutex.RLock()

	argCopy := make([]*StorageMockSavePulseParams, len(mmSavePulse.callArgs))
	copy(argCopy, mmSavePulse.callArgs)

	mmSavePulse.mutex.RUnlock()

	return argCopy
}

// MinimockSavePulseDone returns true if the count of the SavePulse invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSavePulseDone() bool {
	for _, e := range m.SavePulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SavePulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSavePulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSavePulse != nil && mm_atomic.LoadUint64(&m.afterSavePulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockSavePulseInspect logs each unmet expectation
func (m *StorageMock) MinimockSavePulseInspect() {
	for _, e := range m.SavePulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SavePulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SavePulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSavePulseCounter) < 1 {
		if m.SavePulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.SavePulse")
		} else {
			m.t.Errorf("Expected call to StorageMock.SavePulse with params: %#v", *m.SavePulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSavePulse != nil && mm_atomic.LoadUint64(&m.afterSavePulseCounter) < 1 {
		m.t.Error("Expected call to StorageMock.SavePulse")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCompletePulseInspect()

		m.MinimockGetAmountsInspect()

		m.MinimockGetIncompletePulsesInspect()

		m.MinimockGetJetDropByIDInspect()

		m.MinimockGetJetDropsInspect()

		m.MinimockGetJetDropsWithParamsInspect()

		m.MinimockGetLifelineInspect()

		m.MinimockGetPulseInspect()

		m.MinimockGetPulsesInspect()

		m.MinimockGetRecordInspect()

		m.MinimockGetRecordsByJetDropInspect()

		m.MinimockSaveJetDropDataInspect()

		m.MinimockSavePulseInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCompletePulseDone() &&
		m.MinimockGetAmountsDone() &&
		m.MinimockGetIncompletePulsesDone() &&
		m.MinimockGetJetDropByIDDone() &&
		m.MinimockGetJetDropsDone() &&
		m.MinimockGetJetDropsWithParamsDone() &&
		m.MinimockGetLifelineDone() &&
		m.MinimockGetPulseDone() &&
		m.MinimockGetPulsesDone() &&
		m.MinimockGetRecordDone() &&
		m.MinimockGetRecordsByJetDropDone() &&
		m.MinimockSaveJetDropDataDone() &&
		m.MinimockSavePulseDone()
}
